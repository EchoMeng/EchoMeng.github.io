<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Echo Meng">
  <!-- Open Graph Data -->
  <meta property="og:title" content="Core Animation"/>
  <meta property="og:description" content="Can&#39;t help but code." />
  <meta property="og:site_name" content="Echo Meng&#39;s Blog"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://www.echomeng.cn"/>
  
    <link rel="alternate" href="/atom.xml" title="Echo Meng&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>Echo Meng's Blog</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">Core Animation</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/EchoMeng/">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:mengxiangxxa@163.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Echo Meng</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-10-19</span>
            <span class="time">20:18:08</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/技术/">技术</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/iOS/">#iOS</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>iOS视图相关的东西总要系统的看一下Core Animation才能安排的明明白白，这一篇是学习《iOS Core Animation: Advanced Techniques》的笔记，主要是一些之前遗漏或者觉得重要的点的摘录。</p>
<a id="more"></a>
<p>(10.30要发布新的iPad的了，好想买一个能用笔的iPad可是穷QAQ)</p>
<h4 id="drawRect-方法"><a href="#drawRect-方法" class="headerlink" title="drawRect:方法"></a>drawRect:方法</h4><p><code>- drawRect:</code>方法没有默认的实现，对于<code>UIView</code>并不是必须有寄宿图，当检测到<code>drawRect</code>方法被调用之后，才会为视图分配寄宿图。如果没有自定义绘制的任务就不要在子类中写一个空的<code>drawRect</code>方法，会造成CPU和内存资源的浪费。</p>
<h4 id="frame和bounds宽高一定一致吗？"><a href="#frame和bounds宽高一定一致吗？" class="headerlink" title="frame和bounds宽高一定一致吗？"></a>frame和bounds宽高一定一致吗？</h4><p>以前被问到过的一个面试题，这里看到了答案。</p>
<p>当对图层做变换的时候，比如旋转或者缩放，frame实际上代表了覆盖在涂层旋转之后的整个轴对齐的矩形区域，也就是说frame和bounds的宽高可能不再一致。</p>
<p><img src="/images/CoreAnimation/旋转之后frame.png" alt="旋转之后的frame属性"></p>
<h4 id="Z坐标轴"><a href="#Z坐标轴" class="headerlink" title="Z坐标轴"></a>Z坐标轴</h4><p>UIView使用的是严格的二维坐标系，CALayer是存在于三维空间的，有zPosition和anchorPointZ两个属性，可以通过调整zPosition调整视图的显示顺序。</p>
<h4 id="Hit-Testing"><a href="#Hit-Testing" class="headerlink" title="Hit Testing"></a><code>Hit Testing</code></h4><p>CALayer不处理响应链事件，但是<code>- containsPoints:</code> <code>- hitTest:</code> 两个方法是属于layer的。</p>
<p>当调用<code>- hitTest:</code> 方法时，测算的顺序严格依赖于图层树当中的图层顺序，虽然zPosition可以明显改变屏幕上图层的顺序，但是不能改变时间传递的顺序。</p>
<h4 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h4><p>图层的阴影继承自内容的外形，这和图层的边框不同，阴影不是根据边界和角半径确定的，Core Animation会将寄宿图（包括子视图）考虑在内，通过这些来完美搭配图层形状从而创建一个阴影。因此实时计算阴影非常消耗资源，尤其是当图层有多个子视图并且图层有包含透明效果的寄宿图的时候。</p>
<p>可以通过<code>shadowPath</code>指定阴影形状并提高性能。</p>
<h4 id="拉伸过滤"><a href="#拉伸过滤" class="headerlink" title="拉伸过滤"></a>拉伸过滤</h4><p>重绘图片进行拉伸时，<code>CALayer</code>提供了三种拉伸过滤方法：</p>
<ul>
<li>kCAFilterLinear 双线性滤波算法</li>
<li>kCAFilterNearest 三线型滤波算法</li>
<li>kCAFilterTrilinear 最近滤波</li>
</ul>
<p>最近滤波方法图片质量更差，计算更快。</p>
<h4 id="组透明"><a href="#组透明" class="headerlink" title="组透明"></a>组透明</h4><p>直接设置视图的<code>alpha</code>值改变透明度，空间的子视图会有透明度的叠加效果，可以通过设置<code>CALayer</code>的<code>shouldRasterize</code>属性实现组透明效果，在应用透明度之前，图层及子图层都会被整合成为一个整体的图片，这样就没有透明度混合的问题了。</p>
<p><code>shouldRasterize</code>和<code>UIViewGroupOpacity</code>同时使用时，可能会出现性能问题，之后详解。</p>
<h4 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h4><p><code>CAShapeLayer</code>是一个通过矢量图形而不是bitmap来绘制的图层子类。指定颜色、线宽灯属性，用<code>CGPath</code>来定义想要绘制的图形，最后<code>CAShapeLayer</code>就自动渲染出来了。</p>
<p>也可以通过Core Graphics直接向原始的<code>CALayer</code>的内容中绘制一个路径，相比之下，使用<code>CAShapeLayer</code>有以下优点：</p>
<ul>
<li>渲染快速。<code>CAShapeLayer</code>使用了硬件加速，绘制同一个图形会比使用Core Graphics快很多。</li>
<li>高效使用内存。一个<code>CAShapeLayer</code>不需要像普通<code>CALayer</code>一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。</li>
<li>不会被图层边界剪裁掉。一个<code>CAShapeLayer</code>可以在边界之外绘制，图层路径不会像在使用Core Graphics的普通<code>CALayer</code>一样被剪裁掉。</li>
<li>不会出现像素化。当你给<code>CAShapeLayer</code>做3D变换时，不像一个有寄宿图的普通图层一样变得像素化。</li>
</ul>
<h4 id="CATextLayer"><a href="#CATextLayer" class="headerlink" title="CATextLayer"></a>CATextLayer</h4><p>CATextLayer是CALayer的子类，以图层的形式包含了UILabel的几乎所有绘制特性，渲染速度要比UILabel快得多。</p>
<p>Tips:直接用CATextLayer进行文字绘制发现文本有一些像素化了，这是因为没有以Retina的方式进行渲染，contentScale属性用来决定图层内容应该以怎样的分辨率进行选谈，contentScale不关心屏幕的拉伸因素总是默认的乘以1.0，如果想要用Retina的方式显示文字，需要设置contentScale跟屏幕的scale一致。</p>
<p>缺点：CALayer并不支持自动缩放和自动布局，子视图并不能主动跟踪视图边界大小，每次视图大小被更改，就必须手动更新子视图的边界。</p>
<p>CATextLayer比UILabel有更好的性能表现，同时还有额外的布局选项，但是更繁琐。一种思路是创建一个UILabel的子类，然后添加一个字图层CATextLayer并重写显示文本的方法，但是仍然会有UILabel的<code>-drawRect:</code>方法创建的空寄宿图，并且CALayer不会自动布局。对于每一个UIView都寄宿在一个CALayer的实例上，这个图层是由视图自动创建和管理的，一旦被创建就无法替代这个图层，但是我们可以重写<code>+layerClass</code>方法，然后用它的返回类型创建寄宿主图层。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;LayerLabel.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation LayerLabel</span><br><span class="line"></span><br><span class="line">+ (Class)layerClass &#123;</span><br><span class="line">    return [CATextLayer class];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CATextLayer *)textLayer &#123;</span><br><span class="line">    return (CATextLayer *)self.layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setUp &#123;</span><br><span class="line">    self.text = self.text;</span><br><span class="line">    self.textColor = self.textColor;</span><br><span class="line">    self.font = self.font;</span><br><span class="line">    </span><br><span class="line">    [self textLayer].alignmentMode = kCAAlignmentJustified;</span><br><span class="line">    [self textLayer].wrapped = YES;</span><br><span class="line">    [self.layer display];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)initWithFrame:(CGRect)frame &#123;</span><br><span class="line">    if (self = [super initWithFrame:frame]) &#123;</span><br><span class="line">        [self setUp];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)awakeFromNib &#123;</span><br><span class="line">    [super awakeFromNib];</span><br><span class="line">    [self setUp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setText:(NSString *)text &#123;</span><br><span class="line">    super.text = text;</span><br><span class="line">    [self textLayer].string = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setTextColor:(UIColor *)textColor &#123;</span><br><span class="line">    super.textColor = textColor;</span><br><span class="line">    [self textLayer].foregroundColor = textColor.CGColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setFont:(UIFont *)font &#123;</span><br><span class="line">    super.font = font;</span><br><span class="line">    CFStringRef fontName = (__bridge CFStringRef)font.fontName;</span><br><span class="line">    CGFontRef fontRef = CGFontCreateWithFontName(fontName);</span><br><span class="line">    [self textLayer].font = fontRef;</span><br><span class="line">    [self textLayer].fontSize = font.pointSize;</span><br><span class="line">    </span><br><span class="line">    CGFontRelease(fontRef);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="CATransformLayer"><a href="#CATransformLayer" class="headerlink" title="CATransformLayer"></a>CATransformLayer</h4><p>可以用来构造复杂的3D事物。不同于普通的CALayer,它不能展示自己的内容，只有当存在了一个能作用于字图层的变换时才真正存在。CATransformLayer并不平面化他的子图层，所以能够构造一个层级的3D结构。</p>
<h4 id="CAGradientLayer"><a href="#CAGradientLayer" class="headerlink" title="CAGradientLayer"></a>CAGradientLayer</h4><p>用来生成两种或者更过颜色平滑渐变的。使用Core Graphic复制一个CAGradientLayer并将内容绘制在一个普通图层的寄宿图也可以实现，但是CAGradientLayer的优点在于绘制使用了硬件加速。</p>
<h4 id="CAReplicatorLayer"><a href="#CAReplicatorLayer" class="headerlink" title="CAReplicatorLayer"></a>CAReplicatorLayer</h4><p>用来搞笑生成许多相似的图层，它会绘制一个或者多个图层的子图层，并在每个复制体上应用不同的变换。</p>
<h4 id="CAScrollLayer"><a href="#CAScrollLayer" class="headerlink" title="CAScrollLayer"></a>CAScrollLayer</h4><p>CAScrollLayer有一个<code>scrollToPoint:</code><br>方法，自动适应bounds的原点以便图层内容出现在滑动的地方。但是Core Animation是不处理用户输入的，所以CAScrollLayer并不负责将出没时间转换为滑动事件，既不渲染滚动条，也不实现任何iOS指定行为例如滑动反弹。</p>
<h4 id="CATiledLayer"><a href="#CATiledLayer" class="headerlink" title="CATiledLayer"></a>CATiledLayer</h4><p>iOS载入很大的图片由于内存限制载入可能会很慢，在主线程点用还可能会组赛用户界面；内高效绘制在iOS上的图片也有一个大小限制，所有显示在屏幕上的图片都会被转化为OpenGL纹理，同时OpenGL也有一个最大的纹理尺寸，如果想要在单个纹理中显示一个比这个限制要更大的图片，即使这个图片已经存在在内存中了，也可能导致性能问题，因为Core Animation处理图片使用的是CPU而不是更快的GPU。</p>
<p>CATiledLayer提供了一个解决方案：将大图分解成小片然后将它们单独按需求载入。</p>
<h4 id="CAEmitterLayer"><a href="#CAEmitterLayer" class="headerlink" title="CAEmitterLayer"></a>CAEmitterLayer</h4><p>CAEmitterLayer是一个高性能粒子引擎，被用来创建实时粒子动画，例如火、烟雾等。</p>
<h4 id="CAEAGLLayer"><a href="#CAEAGLLayer" class="headerlink" title="CAEAGLLayer"></a>CAEAGLLayer</h4><p>用来显示任意的OpenGL图形。</p>
<h4 id="AVPlayerLayer"><a href="#AVPlayerLayer" class="headerlink" title="AVPlayerLayer"></a>AVPlayerLayer</h4><p>视频播放图层。</p>
<h4 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a>隐式动画</h4><p>之所以叫隐式动画是因为我们并没有制定任何动画的类型，仅仅改变了一个属性，然后Core Animation来决定如何并且何时去做动画。</p>
<p>动画执行的时间取决于当前事务的设置，一旦事务提交就开始用一个动画过渡到新值；动画类型取决于图层的行为。</p>
<p>事务通过CATransaction来管理，可以用<code>+begin</code>和<code>+commit</code>分别来入栈和出栈。</p>
<p>Core Animation在每个runloop周期中自动开始一次新的事务，即使不显式的调用<code>[CATransaction begin]</code>开始一次事务，任何一次runloop循环中属性的改变都会被集中起来，然后做一次0.25s的动画（默认0.25s）。</p>
<p>CALayer属性被修改后进行隐式动画的实现过程：</p>
<ul>
<li>图层首先检测它是否有委托，并且是否实现CALayerDelegate协议指定的<code>-actionForLayer:forKey:</code>方法。如果有，直接调用并返回结果。</li>
<li>如果没有委托，或者没有实现<code>-actionForLayer:forKey:</code>方法，图层接着检查包含属性名称对应行为映射的actions字典。</li>
<li>如果actions字典没有包含对应的属性，那么图层接着在它的style之巅接着搜索属性名。</li>
<li>最后，如果在style里面也找不到对应的行为，那么图层会直接调用定义了没哥属性的标准行为的<code>-defaultActionKey:</code>方法。</li>
</ul>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

