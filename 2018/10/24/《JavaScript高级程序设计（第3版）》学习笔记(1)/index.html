<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Echo Meng">
  <!-- Open Graph Data -->
  <meta property="og:title" content="《JavaScript高级程序设计（第3版）》-- 基础语法部分"/>
  <meta property="og:description" content="Can&#39;t help but code." />
  <meta property="og:site_name" content="Echo Meng&#39;s Blog"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://www.echomeng.cn"/>
  
    <link rel="alternate" href="/atom.xml" title="Echo Meng&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>Echo Meng's Blog</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">《JavaScript高级程序设计（第3版）》-- 基础语法部分</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/EchoMeng/">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:mengxiangxxa@163.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Echo Meng</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-10-24</span>
            <span class="time">09:39:11</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/技术/">技术</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/前端/">#前端</a> <a class="tag" href="/tags/JavaScript/">#JavaScript</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
            
              <div id="toc" class="toc-article">
                <strong class="toc-title">文章目录</strong>
              <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#在HTML中使用JavaScript"><span class="toc-text">在HTML中使用JavaScript</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript语法"><span class="toc-text">JavaScript语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量、作用域和内存问题"><span class="toc-text">变量、作用域和内存问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#变量"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#执行环境"><span class="toc-text">执行环境</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#垃圾收集"><span class="toc-text">垃圾收集</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引用类型"><span class="toc-text">引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Object类型"><span class="toc-text">Object类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Array数组类型"><span class="toc-text">Array数组类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Date类型"><span class="toc-text">Date类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RegExp类型"><span class="toc-text">RegExp类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Function类型"><span class="toc-text">Function类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#基本包装类型"><span class="toc-text">基本包装类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Number类型"><span class="toc-text">Number类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#String类型："><span class="toc-text">String类型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#单体内置类型"><span class="toc-text">单体内置类型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Global对象"><span class="toc-text">Global对象</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Math对象"><span class="toc-text">Math对象</span></a></li></ol></li></ol></li></ol>
              </div>
              
          <p>JavaScript真是一门随意的语言…</p>
<p>这本书应该是比较全面的介绍JavaScript了。可能会看不完，但是算是一个较为系统的学习。</p>
<p>这一部分是前五章的学习笔记，主要介绍相关的基础语法。</p>
<a id="more"></a>
<p>JavaScript是一种专门为与网页交互而设计的脚本语言，由三个部分构成：</p>
<ol>
<li>ECMAScript，由ECMA-262定义，提供核心的语言功能；</li>
<li>文档对象模型（DOM），提供访问和操作网页内容的方法和接口；</li>
<li>浏览器对象模型（BOM），提供与浏览器交互的方法和接口。</li>
</ol>
<h4 id="在HTML中使用JavaScript"><a href="#在HTML中使用JavaScript" class="headerlink" title="在HTML中使用JavaScript"></a>在HTML中使用JavaScript</h4><ul>
<li>带有<code>src</code>属性的<code>&lt;script&gt;</code>元素不应该在<code>&lt;script&gt;</code>和<code>&lt;/script&gt;</code>标签之间包含额外的JavaScript代码，如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。</li>
<li>将所有的外部文件都放在页面的<code>&lt;head&gt;</code>元素中会导致：必须等到全部的JavaScript代码都被下载、解析和执行完成之后，才能开始呈现页面的内容，浏览器是遇到<code>&lt;body&gt;</code>标签之后才会开始呈现内容的。对于包含很多脚本文件的页面来说，会导致浏览器在呈现页面时出现明显的延迟。</li>
<li><code>deger</code>只适用于外部脚本文件，用于表明脚本在执行时不会影响页面的构造，脚本会被延迟到整个页面都解析完毕后再执行，实际执行时间可能在<code>DOMContentLoaded</code>事件触发之前或之后。</li>
<li><code>async</code>只适用于外部脚本文件，用于异步执行，标记为<code>async</code>的脚本并不保证按照指定脚本的先后顺序执行。异步脚本一定会在页面的<code>load</code>事件前执行，但是可能会在<code>DOMContentLoaded</code>事件触发之前或之后执行。</li>
<li>提倡使用外部文件包含JavaScript代码，原因是可维护性、可缓存（重用文件浏览器可以只缓存一次）、适应未来。</li>
</ul>
<h4 id="JavaScript语法"><a href="#JavaScript语法" class="headerlink" title="JavaScript语法"></a>JavaScript语法</h4><ul>
<li>ECMAScript 5引入了严格模式，为JavaScript定义了一种不同的解析和执行模型。需要在代码顶部添加：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"use scrict"</span></span><br></pre></td></tr></table></figure>
<p>这行代码是一个编译指示。</p>
<ul>
<li><p>句尾分号可省略，但是不建议省略。</p>
</li>
<li><p>ECMAScript的变量是松散型的，可以用来保存任何类型的数据，每个变量仅仅是一个用于保存值的占位符而已。可以在修改变量值的过程中同时修改值的类型。</p>
</li>
<li><p>使用<code>var</code>定义的变量将会成为定义该变量的作用域中的局部变量，如果函数中使用<code>var</code>定义一个变量，那么变量在函数退出之后将被销毁。可以省略<code>var</code>操作符定义全局变量，但是不推荐在局部作用域中定义全局变量，会导致难以维护的问题，严格模式下会抛出错误。</p>
</li>
<li><p>ECMAScript有物种简单数据类型：Undefined, Null, Boolean, Number, String，一种复杂数据类型：Object，Object本质是由一组无序的名值对组成的。不支持任何创建自定义类型的机制。</p>
</li>
<li><p>ECMAScript中所有类型的值都等转换为Boolean值，可以调用<code>Boolean()</code>，结果为：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">true</th>
<th style="text-align:center">false</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Boolen</td>
<td style="text-align:center">true</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">Number</td>
<td style="text-align:center">任何非零数字值（包括无穷大）</td>
<td style="text-align:center">0和NaN</td>
</tr>
<tr>
<td style="text-align:center">Object</td>
<td style="text-align:center">任何对象</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">Undefined</td>
<td style="text-align:center">无</td>
<td style="text-align:center">undefined</td>
</tr>
</tbody>
</table>
<ul>
<li><code>NaN</code>:Not a Number。这个数值用来表示一个本来要返回数值的操作数未返回数值的情况（这样就不会直接抛出错误了）。有两个特点：第一，任何涉及NaN的操作（例如<code>NaN</code>/10）都会返回<code>NaN</code>，这个特点在多步计算中有可能会导致问题；第二，<code>NaN</code>和任何值都不想等，包括<code>NaN</code>本身，可以用<code>isNaN()</code>函数判断是否是NaN。</li>
</ul>
<ul>
<li><p><code>parseInt()</code>函数在转换字符串的时候，更多的看其是否符合数值模式，它会忽略字符串前面的空格，知道找到第一个非空格字符。如果第一个字符不是数字字符或者负号，那么直接返回<code>NaN</code>；如果第一个字符是数字字符，<code>parseInt()</code>会继续解析第二个字符，直到解析完成所有后续字符或者遇到了一个非数字字符，之后的非数字字符会被忽略。</p>
</li>
<li><p>ECMAScript中字符串由单引号和双引号表示完全相同。</p>
</li>
<li><p>ECMAScript中字符串是不可变的，字符串一旦创建，它们的值不能改变，要改变某个变量保存在字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。（用起来好像没什么变化，但是先销毁后创建可能导致性能问题，但是在现在浏览器中性能问题已经被修复）。</p>
</li>
<li><p>ECMAScript中的对象其实就是一组数据和功能的集合，可以通过执行<code>new</code>操作符后跟要创建的对象类型的名称来创建。</p>
</li>
<li><p>ECMAScript中所有的数值都以IEEE-754 64位格式存储，但是位操作并不直接操作64位的值，而是先将64位的值转换为32位的整数，然后执行操作，最后再将结果转换为64位。</p>
</li>
<li><p>左移位操作不会影响操作数的符号位；有符号的右移会保留符号位；无符号的右移（<code>&gt;&gt;&gt;</code>）对于正数来说和有符号一致，对于负号来说，由于附属以其绝对值的二进制补码形式表示，因此会导致无符号右移后的结果非常之大。</p>
</li>
<li><p>相等(<code>==</code>)和不相等(<code>!=</code>)操作符存在类型转换问题，全等(<code>===</code>)和不全等(<code>!==</code>)操作不会进行类型转换。</p>
</li>
<li><p><code>label</code>语句可以在代码中添加标签，以便将来使用，语法：<code>label: statement</code></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start: <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">	alert(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中定义的<code>start</code>标签可以再将来由<code>break</code>或<code>continue</code>语句引用。加标签的语句一般都要与<code>for</code>语句等循环语句使用。</p>
<ul>
<li><code>with</code>语句的作用是将代码的作用域设置到一个特定的对象中。<code>with</code>语句的语法：<code>with (expression) statement;</code><br>示例：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = location.search.substring(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> hostName = location.hostname;</span><br><span class="line"><span class="keyword">var</span> url = location.href;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用with可以表述为下面： */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(location) &#123;</span><br><span class="line">	<span class="keyword">var</span> qs = search.substring(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">var</span> hostName = hostname;</span><br><span class="line">	<span class="keyword">var</span> url = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>ECMAScript中函数在定义的时候不必指定是否返回值，任何函数在任何时候都可以通过<code>return</code>语句实现返回值。</p>
</li>
<li><p>理解函数的参数：ECMAScript函数不介意传递进来多少个参数，也不介意传进来的参数是什么数据类型，即使定义额函数只接收两个参数，但是可以传递一个、三个参数甚至不传参数。原因在于，ECMAScript中的参数在内部是用一个数组表示的，函数接受到的始终都是这个数组，而不关心数组中包含哪些参数。在函数体内，可以通过<code>arguments</code>对象来访问这个参数组，可以用方括号语法访问每一个元素，可以用<code>length</code>属性来确定传递进来多少个参数。</p>
</li>
</ul>
<h4 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="headerlink" title="变量、作用域和内存问题"></a>变量、作用域和内存问题</h4><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。</p>
<p>引用类型的值可以添加属性和方法，基本类型值不可以。</p>
<p>如果一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中，不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象，复制操作结束后，两个变量实际上将引用同一个对象。（相当于值类型是深拷贝，引用类型是浅拷贝。）</p>
<p>ECMAScript中所有函数的参数是按值传递的，函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递是值复制，引用类型是指针复制。</p>
<p><code>typeof</code>操作符能确定一个变量是字符串、数值、布尔值，还是<code>undefined</code>；</p>
<p><code>instanceof</code>检测一个变量是不是引用类型。</p>
<h5 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h5><p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义额所有变量和函数都保存在这个对象中，虽然编写代码无妨访问这个对象，但是解析器在处理数据的时候会在后台使用它。</p>
<p>全局执行环境是最外围的一个执行环境，根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。全局执行环境知道应用程序退出（例如浏览器关闭）时才会销毁。</p>
<p>每个函数都有自己的执行环境。当执行流进入到一个函数时，单数的环境就被推入到一个环境栈中。而当这个函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正式由这个机制控制。</p>
<p>当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始时只是一个变量，即<code>arguments</code>对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含环境，而再下一个对象则来自下一个包含环境，这样一直连续到全局执行环境；全局执行环境始终都是作用域链中的最后一个对象。</p>
<p>标识符解析是沿着作用域链一级一级的搜索标识符的过程。搜索过程始终从作用域链的最前端开始，然后逐级地向后回溯，直至找到标识符为止。</p>
<p>执行环境只有全局和局部两种，但是可以延长作用域链，有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。当执行流进入到一下任何一个语句时，作用域链就会得到加长：</p>
<ul>
<li><code>try-catch</code>语句的<code>catch</code>快</li>
<li><code>with</code>语句</li>
</ul>
<p>这两个语句都会在作用域链的前端添加一个变量对象，对<code>with</code>语句来说，会讲指定的对象添加到作用域链中，对于<code>catch</code>语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象声明。</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> qs = <span class="string">"?debug=true"</span>;</span><br><span class="line">	<span class="keyword">with</span>(location) &#123;</span><br><span class="line">		<span class="keyword">var</span> url = href + qs;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>with</code>语句接收的是<code>location</code>对象，因此其变量对象中就包含了<code>location</code>对象的所有属性和方法，而这个变量对象被添加到作用域链的前端。<code>buildUrl()</code>函数中定义了一个变量<code>qs</code>。当在<code>with</code>语句中引用变量<code>href</code>时（实际上引用的是<code>location.href</code>），可以在当前执行环境的变量对象中找到。当引用变量<code>qs</code>的时候，引用的则是在<code>buildUrl()</code>中定义的那个变量，而该变量位于函数环境的变量对象中。至于<code>with</code>语句内部，则定义了一个名为<code>url</code>的变量，因而<code>url</code>就成了函数执行环境的一部分，所以可以作为函数的值被返回。</p>
<p>JavaScript没有块级作用域（花括号作用域）。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(color); <span class="comment">/* blue */</span></span><br></pre></td></tr></table></figure>
<p>JavaScript中if语句中的变量声明会将变量添加到当前的执行环境中。由<code>for</code>语句创建的变量即使在<code>for</code>循环结束后，也依旧会存在于循环外部的执行环境中。</p>
<p>使用<code>var</code>声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在<code>with</code>语句中，最接近的环境是函数环境。如果初始化变量时没有使用<code>var</code>声明，该变量会自动被添加到全局环境。</p>
<p><u>实际上ECMAScript 6 中引入了块级作用域，使用<code>let</code>关键字声明变量即可生成块级作用域。<code>const</code>关键字也可以形成块级作用域，有<code>{}</code>包裹即可。</u></p>
<h5 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h5><p>JavaScript具有自动垃圾回收机制，执行环境会负责管理代码执行过程中使用的内存。</p>
<p>JavaScript中最常用的垃圾收集方式是标记清除。当变量进入环境时（例如在函数中声明一个变量），就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占的内存，因为只要执行流进入相应的环境，就可能会用到它们。当变量离开环境时，则将其标记为“离开环境”。</p>
<p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p>
<p>垃圾收集器时周期性运行的，运行时间策略会影响性能。</p>
<p>因为系统分配给web浏览器的可用内存适量通常要比分配给桌面应用的少，这要是处于安全方面的考虑，防止运行JavaScript的网页耗尽全部系统内存而崩溃。内存限制问题会影响分配给变量的内存，同时会影响调用栈以及在一个线程中能够同时执行的语句数量。因此确保占用最少的内存可以让页面获得更好的性能。优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为<code>null</code>来释放引用，这个方法称为解除引用。这个做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动解除引用。解除一个值的引用并不意味着自动回收该值所占用的内存，真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>ECMAScript中引用类型是一种数据结构，用于将数据和功能组织在一起。也常常被称为类，但是实际上ECMAScript技术上讲虽然是一门面向对象的语言，但是并不具备传统的面向对象的语言所支持的类和接口等基本机构。</p>
<h5 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h5><p>是引用类型,创建方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Jack"</span>;</span><br><span class="line">person.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 也可以用 对象字面量表示法 创建实例 */</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name : <span class="string">"Jack"</span>,</span><br><span class="line">	age : <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="Array数组类型"><a href="#Array数组类型" class="headerlink" title="Array数组类型"></a>Array数组类型</h5><p>ECMAScript数组的每一项可以用来保存任何类型的数据，同一个数组项之间不用保持类型一致。ECMAScript数组的大小可以动态调整，即可以随着数据的添加自动增长以容纳新的数据。数组的<code>length</code>属性不是只读的，可以通过设置这个属性，从数组末尾移除项或者添加新项，这样新增的每一项都会取得<code>undifined</code>值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">	<span class="comment">// 对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>instanceof</code>操作符的问题在于，它嘉定只有一个全局执行环境。如果网页中包含多个框架，实际上就存在多个不同的全局执行环境，从而存在多个不同版本的<code>Array</code>构造函数。如果从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有个字不同的构造函数。ECMAScript5新增了<code>Array.isArray()</code>方法判断到底是不是数组。</li>
<li>ECMAScript为数组提供了<code>push()</code>和<code>pop()</code>方法，一遍实现类似栈的行为；</li>
<li>提供<code>push()</code>和<code>shift()</code>方法模拟队列的行为。<code>unshift()</code>方法可以与<code>shift()</code>想法，在数组前端添加任意个项并返回新数组的长度。</li>
<li>数组的<code>reverse()</code>方法反转数组项的顺序。</li>
<li><code>sort()</code>方法能按升序排列数组项，从小到大排列，会调用每个数组项的<code>toString()</code>方法，然后排序。因为是按字符串排序，常常不能满足需求。<code>sort()</code>方法还能接受一个参数作为比较函数。举个例子：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values); <span class="comment">/* 0, 1, 5, 10, 15 */</span></span><br><span class="line"></span><br><span class="line">values.sort();</span><br><span class="line">alert(values); <span class="comment">/* 0, 1, 10, 15, 5 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>concat()</code>方法可以基于当前数组中的所有项创建一个新数组。具体的，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新创建的数组。在没有给<code>concat()</code>方法传递参数的情况下，它只是复制当前数组并返回副本，如果传递给<code>concat()</code>方法的是一个或者多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单的添加到结果数组的末尾。</li>
<li><code>slice()</code>方法能够基于当前数组中的一个或者多个项创建一个新数组。<code>slice()</code>方法可以接受一个或者多个参数，即要返回项的起始和结束为止。在只有一个参数的情况下，<code>slice()</code>方法返回从该参数指定位置开始到当前数组末尾的所有项。<code>slice()</code>方法不会影响原始数组。</li>
<li><p><code>splice()</code>方法的主要用途是向数组中插入项。包括：</p>
<ol>
<li>删除任意数量的项，需要指定要删除的第一项的位置和要删除的项数；</li>
<li>插入任意数量的项，需要指定起始位置、0（要删除的项数）、要插入的项。如果要插入多个项，可以传入第四、第五或者更多的参数。</li>
<li><p>替换任意数量的项，需要指定起始位置、要删除的项数和要插入的任意数量的项。</p>
<p><code>splice()</code>方法返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除则返回空数组。</p>
</li>
</ol>
</li>
<li><p><code>indexOf()</code>和<code>lastIndexOf()</code>两个位置方法，都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。<code>indexOf()</code>方法从数组的开头（位置0）开始向后查找，<code>lastIndexOf()</code>方法从数组的末尾开始向前查找。两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回<code>-1</code>。</p>
</li>
<li><p>迭代方法：每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响<code>this</code>的值。传入迭代方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。</p>
<ol>
<li><code>every()</code>：对数组中的每一项运行给定函数，如果该函数对每一项都返回<code>true</code>，则返回<code>true</code>。</li>
<li><code>filter()</code>：对数组中的每一项运行给定函数，返回该函数会返回<code>true</code>的项组成的数组。</li>
<li><code>forEach()</code>：对数组中的每一项运行给定函数，这个方法没有返回值。</li>
<li><code>map()</code>：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li><code>some()</code>：对数组中的每一项运行给定函数，如果该函数对任一项返回<code>true</code>，则返回<code>true</code>。只要有一项返回<code>true</code>即返回<code>true</code>。</li>
</ol>
</li>
<li><p>归并方法：<code>reduce()</code>和<code>reduceRight()</code>两个方法都会迭代数组的所有项，然后构建一个最终返回的值。<code>reduce()</code>方法从数组第一项开始，逐个遍历到最后，<code>reduceRight()</code>方法从数组的最后一项开始，向前逐个遍历到第一项。两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传递给<code>reduce()</code>和<code>reduceRight()</code>的函数可以接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。举个例子：使用<code>reduce()</code>方法可以执行求数组中所有值的和：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;;</span><br><span class="line">alert sum; <span class="comment">/* 15 */</span></span><br></pre></td></tr></table></figure>
<h5 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不传递参数情况下新创建的对象自动获得当前日期和时间 */</span></span><br><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure>
<p>构造函数可以传入时间字符串或者时间戳作为参数。</p>
<p><code>Date.parse()</code>方法接受一个表示日期的字符串参数，返回对应时间的时间戳。如果字符串不能表示日期，则返回<code>NaN</code>。</p>
<p><code>Date.UTC()</code>也返回时间戳，但是参数不一样，参数分别是年份、基于0的月份（一月是0）、月中的哪一天、小时数（0-23）、分钟、秒以及毫秒数，只有前两个参数是必须的，省略的参数全部自动填充为0。</p>
<p><code>Date.now()</code>获取当前时间戳。</p>
<p>日期格式化方法：</p>
<ul>
<li><code>toDateString()</code>：以特定于实现的格式显示星期几、月、日和年</li>
<li><code>toTimeString()</code>：以特定于实现的格式显示时、分、秒和时区</li>
<li><code>toLocaleDateString()</code>：以特定于地区的格式显示星期几、月、日和年</li>
<li><code>toLocaleTimeString()</code>：以特定于实现的格式显示时、分、秒</li>
<li><code>toUTCString()</code>：以特定于实现的格式完整的UTC日期</li>
</ul>
<p>具体格式因浏览器而异。</p>
<h5 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h5><p>ECMAScript通过RegExp类型支持正则表达式，使用下面类似Prel的语法，就可以创建一个正则表达式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags;</span><br></pre></td></tr></table></figure>
<p>其中模式（pattern）部分可以是任何简单或者负责的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可以带有一或多个标志（flags），用以标明正则表达式的行为。正则表达式的匹配模式支持下列3个标志：</p>
<ul>
<li>g：表示全局模式，即模式将被应用于所有字符串，并非在发现第一个匹配项时立即停止；</li>
<li>i：表示不区分大小写，即在确定匹配项时忽略模式与字符串的大小写；</li>
<li>m：表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式相匹配的项。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 匹配字符串中所有的“at”实例 */</span></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/at/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 匹配第一个“bat”或者“cat”，不区分大小写 */</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 陪陪所有以“at”结尾的3个字符的组合，不区分大小写 */</span></span><br><span class="line"><span class="keyword">var</span> pattern3 = <span class="regexp">/.at/gi</span>;</span><br></pre></td></tr></table></figure>
<p>模式中使用的所有元字符都必须转义。正在表达式中的元字符包括:<br><code>( [ { \ ^ $ | ) ? * + . ] }</code></p>
<p>除了上述使用字面量形式来定义的正则表达式，另一种创建正则表达式的方式是使用RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> RecExp(<span class="string">"[bc]at"</span>, <span class="string">"i"</span>);</span><br></pre></td></tr></table></figure>
<p>RegExp每个实例具备以下属性：</p>
<ul>
<li><code>global</code>:布尔值，是否设置了g标志</li>
<li><code>ignoreCase</code>:布尔值，是否设置了i标志</li>
<li><code>lastIndex</code>:整数，表示开始搜索下一个匹配项的字符位置，从0算起</li>
<li><code>multiline</code>:布尔值，表示是否设置了m标志</li>
<li><code>source</code>:正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回</li>
</ul>
<p>RegExp对象的主要方法是<code>exec()</code>，该方法是专门为捕获组而设计的。接收一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回<code>null</code>。返回的数组虽然是<code>Array</code>的实例，但是包含两个额外的属性：<code>index</code>和<code>input</code>。<code>index</code>表示匹配项在字符串中的位置，<code>input</code>表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"mom and dad and baby"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = pattern.exec(text);</span><br><span class="line">alert(matches.index); <span class="comment">/* 0 */</span></span><br><span class="line">alert(matches.input); <span class="comment">/* "mom and dad and baby" */</span></span><br><span class="line">alert(matches[<span class="number">0</span>]); <span class="comment">/* "mom and dad and baby" */</span></span><br><span class="line">alert(matches[<span class="number">1</span>]); <span class="comment">/* " and dad and baby" */</span></span><br><span class="line">alert(matches[<span class="number">2</span>]); <span class="comment">/* " and baby" */</span></span><br></pre></td></tr></table></figure>
<h5 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h5><p>每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p>
<p>ECMAScript中没有函数重载的概念，声明两个同名函数的结果是后声明额函数覆盖先声明的函数。</p>
<p>把函数名看作是置身，函数名本身就是变量，函数可以作为值使用，可以像传递参数一样把一个函数传递给另一个函数，可以将一个函数作为另一个函数的结果返回。</p>
<p>在函数内部有两个特殊对象:<code>arguments</code>和<code>this</code>。<code>arguments</code>是一个类数组对象，包含着传入函数的所有参数，这个对象有一个<code>callee</code>属性，该属性是一个指针，指向拥有这个<code>arguments</code>对象的函数。<code>this</code>对象引用的是函数执行的环境对象。</p>
<p>ECMAScript 5规范化了一个函数对象的属性：<code>caller</code>。这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为<code>null</code>。</p>
<p>严格模式下，访问<code>arguments.callee</code>会导致错误。<code>arguments.caller</code>会导致错误，而在非严格模式下，始终为<code>undefined</code>。定义<code>arguments.callee</code>属性是为了分清<code>arguments.caller</code>和函数的<code>caller</code>属性。严格模式下，不能为函数的<code>caller</code>属性赋值，否则会导致错误。这些错误是为了加强语言安全性，防止第三方代码在相同的环境下窥视其他代码。</p>
<p>每个函数都包含两个属性：<code>length</code>和<code>prototype</code>。<code>length</code>属性表示函数希望接收的命名参数的个数。ECMAScript的引用类型中，<code>prototype</code>是保存它们所有实例方法的真正所在，也就是说，诸如<code>toString()</code>和<code>valueOf()</code>等方法实际上都保存在<code>prototype</code>名下，只不过通过各自对象的实例访问罢了。<code>prototype</code>属性是不可枚举的，因此使用<code>for-in</code>方法无法发现。</p>
<p>每个函数都包含两个非继承而来的方法：<code>apply()</code>和<code>call()</code>。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内<code>this</code>对象的值。<code>apply()</code>方法接收两个参数：一个是在其中运行的参数的作用域，另一个是参数数组，第二个参数可以是<code>Array</code>的实例，也可以是<code>argumets</code>对象。<code>call()</code>方法作用一样，只是第二个参数不一样，是直接逐个传入不需要数组。这两个函数强大的用处在于：可以扩充函数运行的作用域。举例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor(); <span class="comment">/* red */</span></span><br><span class="line">sayColor.call(<span class="keyword">this</span>); <span class="comment">/* red */</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>); <span class="comment">/* red */</span></span><br><span class="line">sayColor.call(o); <span class="comment">/* blue */</span></span><br></pre></td></tr></table></figure>
<p>以上通过修改<code>this</code>对象实现的，最后一种情况下函数的执行环境不一样了，<code>this</code>对象指向了<code>o</code>。</p>
<p>ECMAScript 5还定义了一个方法：<code>bind()</code>。这个方法会创建一个新的函数的实例，其<code>this</code>值会被绑定到传给<code>bind()</code>函数的值。举例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor(); <span class="comment">/* blue */</span></span><br></pre></td></tr></table></figure>
<h5 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h5><p>ECMAScript还提供三种特殊引用类型：Boolean, Number, String，叫做基本包装类型。</p>
<p>基本包装类型和引用类型最主要的区别就是对象的生命周期，使用<code>new</code>操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，也就意味着不能在运行时为基本类型值添加属性和方法。举例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</span><br><span class="line">s1.color = <span class="string">"red"</span>;</span><br><span class="line">alert(s1.color); <span class="comment">/* undefined */</span></span><br></pre></td></tr></table></figure>
<p>第二行创建的<code>String</code>对象在执行第三行代码时已经被销毁了，第三行代码又创建了自己的<code>String</code>对象，而该对象没有<code>color</code>属性。</p>
<p>对基本包装类型的实例调用<code>typeof</code>会返回<code>object</code>，而且所有的基本包装类型的对象在转换为布尔类型的时候值都是<code>true</code>。使用<code>new</code>调用基本包装类型的构造函数，调用<code>typeof</code>返回<code>“object”</code>。</p>
<h5 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a><code>Number</code>类型</h5><p>对Number类型的实例调用<code>toString()</code>，可以传递一个表示基数的参数，告诉它返回几进制数值的字符串形式。调用<code>toFixed()</code>方法可以传入一个表示保留几位小数的参数。<code>toExponential()</code>方法返回以科学记数法表示的数值的字符串形式，接收一个参数表示输出结果中的小数位数。<code>toPrecision()</code>方法会决定用<code>toFixed()</code>方法还是<code>toExponential()</code>方法，通过向下或者向上舍入，做到以最准确的形式来表示带有正确的小数位的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">alert(num.toString(<span class="number">16</span>)); <span class="comment">/* 16进制 “a”*/</span></span><br><span class="line">alert(num.toFixed(<span class="number">2</span>)); <span class="comment">/* 保留两位小数 10.00 */</span></span><br><span class="line">alert(num.toExponential(<span class="number">1</span>)); <span class="comment">/* 1.0e+1 */</span></span><br></pre></td></tr></table></figure>
<h5 id="String类型："><a href="#String类型：" class="headerlink" title="String类型："></a><code>String</code>类型：</h5><p>两个用于访问字符串中特定字符的方法：<code>charAt()</code>和<code>charCodeAt()</code>。两个方法都接收一个参数，基于0的字符位置，前者以单字符字符串的形式返回给定位置的字符（ECMAScript中是没有字符类型的），后者以字符对应的字符编码形式返回。</p>
<p><code>concat()</code>用于将一个或者多个字符串拼接起来，返回拼接后字符串。同样的效果，实际中用<code>+</code>比较常见。</p>
<p><code>slice()</code>、<code>substr()</code>、<code>substring()</code>都返回被操作字符串的一个子字符串。都接收一个或者两个参数，第一个参数指定子字符串的开始位置，第二个字符串（在指定的情况下）表示子字符串在哪里结束。<code>slice()</code>和<code>substring()</code>的第二个参数指定的是子字符串最后一个字符后面的位置，<code>substr()</code>的第二个参数指定的是返回的字符个数。如果没有第二个参数，那么以字符串末尾作为结束。返回一个字符串，不改变原字符串。</p>
<p>在传递给这些方法的参数是负数的情况下，三个函数行为不同。<code>slice()</code>方法会将传入的负数与字符串的长度相加，<code>substr()</code>方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0，<code>substring()</code>方法会把所有的负值参数都转换为0。</p>
<p><code>trim()</code>方法创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。</p>
<p>字符串大小写转换方法：<code>toLowerCase()</code>、<code>toLocaleLowerCase()</code>、<code>toUpperCase()</code>、<code>toLocaleUpperCase()</code></p>
<p>字符串模式匹配方法：<code>match()</code>，只接收一个参数，要么是一个正则表达式，要么是一个<code>RegExp</code>对象，返回一个数组。</p>
<p><code>search()</code>和<code>match()</code>类似，返回匹配字符串中第一个匹配项的索引，如果没有返回<code>-1</code>，并且只能从头向后查找。</p>
<p>替换字符串：<code>replace()</code>方法，第一个参数是<code>RegExp</code>对象或者是一个字符串，第二个参数可以是一个字符串或者函数。在只有一个匹配项的情况下（即与模式匹配的字符串），会向这个函数传递三个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;"&amp;]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, pos, originalText</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span>(match) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"&lt;"</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">"&amp;lt;"</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"&gt;"</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">"&amp;gt;"</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"&amp;"</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">"&amp;amp;"</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"\""</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="string">"&amp;quot;"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>split()</code>方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中，分隔符可以是字符串，也可以是<code>RegExp</code>对象。还有可选的第二个参数，用来指定返回数组中项的数目。</p>
<p><code>localeCompare()</code>比较两个字符串在字母表的顺序，如果在之前，返回<code>1</code>，如果相等，返回<code>0</code>，否则返回<code>-1</code>。这个方法与支持的地区有关，在英语中区分大小写。</p>
<p><code>fromCharCode()</code>方法接收一或者多个字符编码，然后将它们转换成一个字符串。</p>
<h5 id="单体内置类型"><a href="#单体内置类型" class="headerlink" title="单体内置类型"></a>单体内置类型</h5><p>内置类型是由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了，开发人员不用显式的实例化内置对象。Object、Array、String都是内置对象，还有两个单体内置对象：Global和Math。</p>
<h6 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h6><p>所有在全局作用域中定义的属性和函数，都是<code>Global</code>对象的属性，例如<code>isNaN()</code>、<code>isFinite()</code>、<code>parseInt()</code>、<code>parseFloat()</code>都是<code>Global</code>对象的属性。</p>
<p><code>Global</code>对象的<code>encodeURI()</code>和<code>encodeURIComponent()</code>方法可以对URI进行编码，以便发送给浏览器。有效的URI编码中不能包含有些字符，例如空格，这个两个方法会对无效字符进行替换。<code>encodeURI()</code>不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而<code>encodeURIComponent()</code>则会对它发现的任何非标准字符进行编码。解码方法分别对应<code>decodeURI()</code>和<code>decodeURIComponent()</code>。</p>
<p><code>eval()</code>方法就像一个完整的ECMAScript解析器，只接收一个参数，即要执行的ECMAScript字符串。当解析器发现代码中调用<code>eval()</code>方法时，它会将传入的参数当作实际的ECMAScript语句解析，然后把执行结果插入到原位置。通过<code>eval()</code>执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着<code>eval()</code>执行的代码可以引用在包含环境中定义的变量。在严格模式下，外部访问不到<code>eval()</code>中创建的任何变量或者函数。</p>
<h6 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(); <span class="comment">/* 接收任意多个参数，求最大值 */</span></span><br><span class="line"><span class="built_in">Math</span>.min(); <span class="comment">/* 接收任意多个参数，求最大值 */</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(); <span class="comment">/* 执行向上舍入的最接近的整数 */</span></span><br><span class="line"><span class="built_in">Math</span>.floor(); <span class="comment">/* 执行向下舍入的最接近的整数 */</span></span><br><span class="line"><span class="built_in">Math</span>.round(); <span class="comment">/* 执行四舍五入的最接近的整数 */</span></span><br><span class="line"><span class="built_in">Math</span>.random(); <span class="comment">/* 返回大于等于0小于1的一个随机数 */</span></span><br></pre></td></tr></table></figure>
<hr>
<p>以上为前五章内容的摘录笔记，主要是语法相关内容，JavaScript这种解释型语言和编译型语言还是呈现出很多不一样的特性。</p>
<p>可能要暂停一段时间写毕业论文了QAQ…</p>
<p>之后有时间会再另起一篇学习一下跟JavaScript设计模式、原理相关的内容。</p>
<p>加油鸭！</p>
<hr>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

