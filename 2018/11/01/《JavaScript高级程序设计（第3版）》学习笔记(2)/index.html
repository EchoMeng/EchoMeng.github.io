<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Echo Meng">
  <!-- Open Graph Data -->
  <meta property="og:title" content="《JavaScript高级程序设计（第3版）》-- 面向对象"/>
  <meta property="og:description" content="Can&#39;t help but code." />
  <meta property="og:site_name" content="Echo Meng&#39;s Blog"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://www.echomeng.cn"/>
  
    <link rel="alternate" href="/atom.xml" title="Echo Meng&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>Echo Meng's Blog</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">《JavaScript高级程序设计（第3版）》-- 面向对象</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/EchoMeng/">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:mengxiangxxa@163.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Echo Meng</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-11-01</span>
            <span class="time">10:09:35</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/技术/">技术</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/前端/">#前端</a> <a class="tag" href="/tags/JavaScript/">#JavaScript</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
            
          <p>上一篇把基础语法部分看了看，坦白说不知道在应用的过程中能用到多少、什么程度。</p>
<p>这一部分是六、七章面向对象的程序设计以及函数表达式的学习笔记。</p>
<a id="more"></a>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向对象的语言有一个标志，就是都有类，通过类可以创建任意多个具有相同属性和方法的对象。ECMAScript中没有类的概念，因此与其他面向对象的语言不同。</p>
<p>ECMA-262中对对象的定义：无序属性的集合，其属性可以包含基本值、对象或者函数。严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。因此可以把ECMAScript的对象想象成散列表的名值对，其中值可以是数据或者函数。</p>
<p>ECMAScript中有两种属性：数据属性和访问器属性。</p>
<p>数据属性包含一个数据值的位置，在这个位置可以读取和写入值。数据属性有4个描述其行为的特性：</p>
<ol>
<li><code>[[Configurable]]</code>：表示能否通过<code>delete</code>删除属性从而定义属性，能够修改属性的特性，或者能否把属性修改为访问器属性。对直接在对象上定义的属性默认为<code>true</code>。</li>
<li><code>[[Enumerable]]</code>：表示能否通过<code>for-in</code>循环返回属性。对直接在对象上定义的属性默认为<code>true</code>。</li>
<li><code>[[Writable]]</code>：表示能否修改属性的值。对直接在对象上定义的属性默认为<code>true</code>。</li>
<li><code>[[Value]]</code>：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值是<code>undefined</code>。</li>
</ol>
<p>要修改默认的特性，需要用<code>Object.defineProperty()</code>方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符对象的属性必须是<code>configurable</code>、<code>enumerable</code>和<code>value</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.definProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">	writable: <span class="literal">false</span>,</span><br><span class="line">	value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;);</span><br><span class="line">alert(person.name); <span class="comment">/* Nicholas */</span></span><br><span class="line">person.name = <span class="string">"Greg"</span>;</span><br><span class="line">alert(person.name); <span class="comment">/* Nicholas */</span></span><br></pre></td></tr></table></figure>
<p>访问器属性不包含数据值，它们包含<code>getter</code>和<code>setter</code>函数，但是这两个函数都不是必须的。在读取访问器属性的时候，会调用<code>getter</code>函数，这个函数负责返回有效的值；在写入访问器属性时，会调用<code>setter</code>函数并传入新值，这个函数负责决定如何处理数据。访问器属性有4个特性：</p>
<ol>
<li><code>[[Configurable]]</code>：表示能否通过<code>delete</code>删除属性从而定义属性，能够修改属性的特性，或者能否把属性修改为访问器属性。对直接在对象上定义的属性默认为<code>true</code>。</li>
<li><code>[[Enumerable]]</code>：表示能否通过<code>for-in</code>循环返回属性。对直接在对象上定义的属性默认为<code>true</code>。</li>
<li><code>[[Get]]</code>：在读取属性时调用的函数，默认值为<code>undefined</code>。</li>
<li><code>[[Set]]</code>：在写入属性时调用的函数，默认值为<code>undefined</code>。</li>
</ol>
<p>访问器属性不能直接定义，指定通过<code>Object.defineProperty()</code>方法定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">	_year: <span class="number">2004</span>,</span><br><span class="line">	edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</span><br><span class="line">	get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">	&#125;,</span><br><span class="line">	set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>._year = newValue;</span><br><span class="line">			<span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition); <span class="comment">/* 2 */</span></span><br></pre></td></tr></table></figure>
<p>访问器属性的常用方式：设置一个属性值会导致其他属性值发生变化的情况。不一定非要同时指定<code>getter</code>和<code>setter</code>。只指定<code>getter</code>意味着属性不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定<code>getter</code>函数的属性会抛出错误。类似的，只指定<code>setter</code>会导致不能读，负责在非严格模式下，会返回<code>undefined</code>，严格模式下会抛出错误。</p>
<p>使用<code>Object.getOwnPropertyDescriptor()</code>方法可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有<code>configutable</code>、<code>enumerable</code>、<code>get</code>、<code>set</code>；如果是数据属性，这个对象的属性有<code>configurable</code>、<code>enumerable</code>、<code>writable</code>、<code>value</code>。</p>
<p>JavaScript中，可以针对任何对象，包括DOM、BOM对象，使用<code>Object.getOwnPropertyDescriptor()</code>方法。</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.name = name;</span><br><span class="line">	o.age = age;</span><br><span class="line">	o.job = job;</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = creatPerson(<span class="string">"Sam"</span>, <span class="number">29</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>
<p>工厂模式解决了创建多个相似对象产生重复代码的问题，但是没有解决对象识别问题，即怎样知道一个对象的类型。</p>
<h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">	<span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">30</span>, <span class="string">"Worker"</span>);</span><br></pre></td></tr></table></figure>
<p>与工厂模式的区别：没有显示的创建对象，直接将属性和方法赋给了<code>this</code>对象，没有<code>return</code>语句。</p>
<p>Tips: 按照惯例，构造函数都要用一个大写字母开头，非构造函数都要以小写字母开头。</p>
<p>而创建构造函数对应的实例，必须要用一个<code>new</code>操作符。这种方式调用构造函数实际上会经历以下4个步骤：</p>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象，因此<code>this</code>就指向了新对象；</li>
<li>执行构造函数中的代码，为新对象增加属性；</li>
<li>返回新对象。</li>
</ol>
<p>构造函数模式的问题：每个方法都要在每个实例上重新创建一遍。ECMAScript中函数是对象，因此每定义一个函数，也就是实例化了一个对象。（指的是<code>sayName()</code>函数）为了解决这个问题，可以把<code>sayName()</code>函数转移到函数外部，但是这样又会导致函数称为一个全局函数，所有对象都可以调用，没有封装性可言了。</p>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>我们创建的每一个函数都有一个<code>prototype</code>属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。<code>prototype</code>是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有的对象实例共享它所包含的属性和方法，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">"Sam"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Doctor"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">/* Sam */</span></span><br></pre></td></tr></table></figure>
<p>这个时候构造函数成了空函数，直接将方法和属性添加到Person的原型中，仍然可以通过构造函数创建对象，对象之间的属性和方法是共享的。</p>
<h6 id="原型对象："><a href="#原型对象：" class="headerlink" title="原型对象："></a>原型对象：</h6><p>无论是什时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个<code>prototype</code>属性，这个属性指向函数的原型对象。在默认情况下，所有的原型对象都会自动获得一个<code>constructor</code>（构造函数）属性，这个属性是一个只想<code>prototype</code>属性所在函数的指针。例如上例中<code>Person.prototype. constructor</code>指向<code>Person</code>。而通过这个构造函数，还可以继续为原型对象添加其他属性和方法。</p>
<p>创建了自定义的构造函数之后，其原型对象默认只会取得<code>constructor</code>属性；至于其他的方法，都是从<code>Object</code>继承而来的。当调用构造函数创建一个新实例后，该函数的内部将包含一个指针（内部属性），指向构造函数的原型对象(<code>[[Prototype]]</code>)；这个连接存在于实例和构造函数的原型对象之间，而不是存在于实例和构造函数之间；这个属性实现中无法访问到。</p>
<p><img src="/images/js/prototype.jpeg" alt="原型与实例"></p>
<p>当代码读取某个对象的某个属性时，会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始，如果实例中找到了具有给定名字的属性，则返回该属性值；如果没有找到，则继续搜索属性的原型对象，在原型对象中查找具有给定名字的属性，如果找到了，则返回属性值。</p>
<p>虽然可以通过对象实例访问保存在原型中的值，但是却不能通过对象实例重写原型中的值。如果在实例中添加了一个属性，而该属性与实例原型中的属性同名，那么就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。但是，使用<code>delete</code>操作符可以完全删除实例属性，从而让我们能够重新访问原型中属性。</p>
<p><code>hasOwnProperty()</code>方法可以检测一个属性时存在于实例中，还是存在于原型中。只在给定属性存在于对象实例中时，才会返回<code>true</code>。</p>
<p><code>in</code>操作符会在通过对象能够访问给定属性时返回<code>true</code>，无论该属性存在于实例中还是原型中。</p>
<p>在使用<code>for-in</code>循环时，返回的是所有能够通过对象访问的、可枚举的属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（将<code>[[Enumerable]]</code>标记为<code>false</code>的属性）的实例属性也会在<code>for-in</code>循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的，IE8及更早的版本中例外。</p>
<p>更简单的原型语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	name : <span class="string">"Sam"</span>,</span><br><span class="line">	age : <span class="number">29</span>,</span><br><span class="line">	job : <span class="string">"Doctor"</span>,</span><br><span class="line">	sayName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种原型语法本质上重写了默认的<code>prototype</code>对象，因此<code>constructor</code>属性也变成了新对象的<code>constructor</code>属性（指向Object构造函数），不再指向<code>Person</code>构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">alert(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">/* true */</span></span><br><span class="line">alert(friend <span class="keyword">instanceof</span> Person); <span class="comment">/* true */</span></span><br><span class="line">alert(friend.constructor == Person); <span class="comment">/* false */</span></span><br><span class="line">alert(friend.constructor == <span class="built_in">Object</span>); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>
<p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能立即从实例上反映出来，即使是先创建了实例后修改原型也是如此。</p>
<p>尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反应出来，但是如果是重写整个原型对象，情况就会不同了。调用构造函数时会为实例添加一个指向最初原型的<code>[[Prototype]]</code>指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。实例中的指针仅指向指针，而不指向构造函数。</p>
<p>原生对象也有原型，但是不推荐修改，因为容易因为命名冲突导致意外重写原生方法。</p>
<p>原型对象的问题：</p>
<ol>
<li>省略了为构造函数传递初始化参数这一环节，结果所有的实例在默认情况下都将获得相同的属性值。</li>
<li>原型中所有属性是被很多实例共享的，这种共享对于函数非常合适，对于那些包含基本值的属性也可以使用，可以通过在实例上添加同名属性隐藏原型中的对应属性，但是对于包含引用类型值（例如数组）的属性来说，问题就比较突出了。因此很少单独使用原型模式。</li>
</ol>
<h4 id="构造函数模式-原型模式"><a href="#构造函数模式-原型模式" class="headerlink" title="构造函数模式+原型模式"></a>构造函数模式+原型模式</h4><p>创建自定义类型最常见的方式是组合使用构造函数模式和原型模式。</p>
<p>构造函数模式用于定义实例属性，二原型模式用于定义方法和共享的属性。结果每个实例都会有自己的一份实例属性的副本，但是同时又共享着对方法的引用，最大限度的节省内存。另外，这种混成模式还支持向构造函数传递参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">	<span class="keyword">this</span>.friend = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	<span class="keyword">constructor</span>: Person,</span><br><span class="line">	sayName: function() &#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Sam"</span>, <span class="number">29</span>, <span class="string">"Dcotor"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Amy"</span>, <span class="number">20</span>, <span class="string">"Worker"</span>);</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line">alert(person1.friends); <span class="comment">/* "Shelby, Court, Van" */</span></span><br><span class="line">alert(person2.friends); <span class="comment">/* "Shelby, Court" */</span></span><br><span class="line">alert(person1.friends === person2.friends); <span class="comment">/* false */</span></span><br><span class="line">alert(person1.sayName === person.sayName); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>
<h4 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h4><p>动态原型模式把所有信息封装在构造函数中，二通过在构造函数中初始化原型（在必要的情况下），又保持了同时使用构造函数和原型的有点。可以通过检查某个应该存在的方法是否有效，来决定是否需要进行原型的初始化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</span><br><span class="line">		Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			alert(<span class="keyword">this</span>.name);</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Sam"</span>, <span class="number">20</span>, <span class="string">"Doctor"</span>);</span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure>
<p>这个时候，只有在<code>sayName()</code>方法不存在的情况下，才会将它添加到原型中，并且这段代码只有在初次调用构造函数的时候才会执行。</p>
<h4 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.name = name;</span><br><span class="line">	o.age = age;</span><br><span class="line">	o.job = job;</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Sam"</span>, <span class="number">19</span>, <span class="string">"Doctor"</span>);</span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure>
<h4 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(name);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>很多面向对象语言都支持两种继承方式：接口继承和实现继承。接口即成只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其继承主要是依靠原型链实现。</p>
<p>利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<p>原型链的基本概念：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。如果让原型对象等于另一个类型的实例，此时原型对象将包含一个指向另一个原型的指针，相应的，另一个原型中也包含一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，构成了实例与原型的链条。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">superType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 继承了SuperType */</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(indtance.getSuperValue()); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>
<p>以上代码定义了两个类型：<code>SuperType</code>和<code>SubType</code>。每个类型分别有一个属性和一个方法，它们的主要区别是<code>SubType</code>继承了<code>SuperType</code>，而继承是通过创建<code>SuperType</code>的实例，并将该实例赋值给<code>SubType.prototype</code>实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于<code>SuperType</code>的实例中的所有属性和方法，现在也存在于<code>SubType.prototype</code>中。</p>
<p><img src="/images/js/继承.jpeg" alt="继承的实现"></p>
<p>使用<code>instanceof</code>操作符或者<code>isPrototypeOf()</code>方法，只要是原型链中出现过的原型，都可以说是该原型链派生的实例，返回<code>true</code>。</p>
<p>子类型有时候需要覆盖超类型中的某个方法，或者需要添加超类型中不存在的某个方法，不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后。</p>
<p>通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样做会重写原型链。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">superType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 继承了SuperType */</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用字面量添加新方法，会导致上一行代码无效 */</span></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">	getSubValue : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">	&#125;;</span><br><span class="line">	someOtherMethod : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.getSuperValue()); <span class="comment">/* error */</span></span><br></pre></td></tr></table></figure>
<p>原型链的问题：</p>
<p>主要来自包含引用类型值的原型。在通过原型实现继承时，原型实际上会变成另一个类型的实例，于是，原先的实例属性也就成为了现在的原型属性了。</p>
<p>第二个问题：创建子类型的实例时，不能向超类型的构造函数中传递参数，实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</p>
<p>以上，实践中很少单独使用原型链。</p>
<h6 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h6><p>为了解决原型中包含引用类型值带来的问题，采用一种叫做借用构造函数的技术（也叫伪造对象或者经典继承）。基本思想是在子类型构造函数的内部调用超类型构造函数。函数只不过是在特定环境下执行代码的对象，因此通过使用<code>apply()</code>或者<code>call()</code>方法也可以在（将来）新创建的对象上执行构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">/* 继承了SuperType */</span></span><br><span class="line">	SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.clolors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">/* "red, blue, green, black" */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors); <span class="comment">/* "red, blue, green" */</span></span><br></pre></td></tr></table></figure>
<p>借用构造函数可以实现在子类型构造函数中向超类型构造函数传递参数。</p>
<p>问题：方法都在构造函数中定义，因此函数无法复用。而且在超类型中定义的方法，对子类型来说是不可见的，结果是所有类型都只能使用构造函数模式。</p>
<p>以上，借用构造模式也很少单独使用。</p>
<h6 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h6><p>组合继承（伪经典继承）指的是将原型链和借用构造函数的技术组合在一起。思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有自己的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	<span class="comment">/* 继承属性 */</span></span><br><span class="line">	SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 继承方法 */</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Sam"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">/* "red, blue, green, black" */</span></span><br><span class="line">instance1.sayName(); <span class="comment">/* "Sam" */</span></span><br><span class="line">instance1.sayAge(); <span class="comment">/* 29 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Amy"</span>, <span class="number">20</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">/* "red, green, black" */</span></span><br><span class="line">instance2.sayName(); <span class="comment">/* "Amy" */</span></span><br><span class="line">instance2.sayAge(); <span class="comment">/* 20 */</span></span><br></pre></td></tr></table></figure>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>原型式继承的基本思想：借助原型可以基于已有对象创建新对象，同时不必因此创建自定义类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">	funtion F()&#123;&#125;</span><br><span class="line">	F.prototype = o;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>object()</code>函数内部，先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，<code>object()</code>对传入其中的对象执行了一次浅复制。</p>
<p>在没有必要兴师动众的创建构造函数，而指向让一个对象和另一个对象保持相似的情况下，原型式继承可以胜任。包含引用类型值的属性始终会共享相应的值，就像使用原型模式一样。</p>
<p>ECMAScript 5中使用<code>Object.create()</code>方法规范化了原型式继承。这个方法接收两个参数，一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，<code>Object.create()</code>与<code>object()</code>方法的行为相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name: <span class="string">"Amy"</span>,</span><br><span class="line">	friends: [<span class="string">"Bob"</span>, <span class="string">"Sam"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.creat(person, &#123;</span><br><span class="line">	name: &#123;</span><br><span class="line">		value: <span class="string">"Greg"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(anotherPerson.name); <span class="comment">/* Greg */</span></span><br></pre></td></tr></table></figure>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样的返回函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> clone = object(original); <span class="comment">/* 通过调用函数创建一个新对象 */</span></span><br><span class="line">	clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* 以某种方式来增强这个对象 */</span></span><br><span class="line">		alert(<span class="string">"hi"</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> clone; <span class="comment">/* 返回这个对象 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式，任何能够返回新对象的函数都适用于此模式。寄生式继承会由于不能做到函数复用而降低效率。</p>
<h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>组合继承最大的问题是无论什么情况下，都会调用两次超类型构造函数，一次在创建子类型原型的时候，另一次在子类型构造函数内部。子类型最终会包含超类型对象的全部实例属性，但是不得不在调用子类型构造函数的时候重写这些属性。</p>
<p>寄生组合式继承，就是通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的只是超类型的一个副本。本质上，就是使用寄生式继承超类型的原型，然后再将结果指定给子类型的原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> prototype = object(superType,.prototype); <span class="comment">/* 创建对象 */</span></span><br><span class="line">	prototype.constructor = subType; <span class="comment">/* 增强对象 */</span></span><br><span class="line">	subType.prototype = prototype; <span class="comment">/* 指定对象 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式在开发中应用最多。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>JavaScript定义函数的方式有两种：函数声明和函数表达式。</p>
<p>函数声明的一个重要特征是函数声明提升，意思是执行代码之前会先读取函数声明，这就意味着可以把函数声明放在调用它的语句后面。这是对于函数声明而言的，很关键！！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数声明式 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">arg0, arg1, arg2</span>) </span>&#123;</span><br><span class="line">	<span class="comment">/* 函数体 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数表达式 */</span></span><br><span class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params">arg0, arg1, arg2</span>) </span>&#123;</span><br><span class="line">	<span class="comment">/* 函数体 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> num * factorial(num - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherFactorial = factorial;</span><br><span class="line">factorial = <span class="literal">null</span>;</span><br><span class="line">alert(anotherFactorial(<span class="number">4</span>)); <span class="comment">/* 出错 */</span></span><br></pre></td></tr></table></figure>
<p>这个时候会出错，因为执行<code>anotherFactorial ()</code>执行必须要调用<code>factorial()</code>，但是<code>factorial()</code>已经不指向原函数。</p>
<p>使用<code>arguments.callee</code>，他是一个指向正在执行的函数的指针，用它可以实现对函数的递归调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上不会出错，通过使用<code>arguments.callee</code>代替函数名，可以确保无论怎样调用函数都不会出问题，在写递归函数的时候，使用<code>arguments.callee</code>会比使用函数名更保险。</p>
<p>在严格模式下，不能通过脚本访问<code>arguments.callee</code>，访问这个属性会导致错误。不过可以使用命名函数表达式达成相同的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> num * f(num<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">		<span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line">		<span class="comment">/* 以上两行代码式内部函数中的代码，访问了外部函数中的变量 propertyName */</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(value1 &lt; value2) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(value1 &gt; value2) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当某个函数被调用时，会创建一个执行环境及相应的作用域链。然后，使用<code>arguments</code>和其他命名参数的值来初始化函数的活动对象。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位···直到作为作用域链终点的全局执行环境。</p>
<p>在函数执行过程中，为了读取和写入变量的值，就需要在作用域链中查找变量。后台的每个执行环境中都有一个表示变量的对象——变量对象。全局执行环境的变量对象始终存在，而局部环境的变量对象，则只在函数执行的过程中存在。在创建局部函数的时候，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部<code>[[Scope]]</code>属性中。当调用局部函数的时候，会为函数创建一个执行环境，然后通过复制函数的<code>[[Scope]]</code>属性中的对象构建起执行环境的作用域链。作用域链本事上是一个指向变量对象的指针列表，只引用但是不实际包含对象。</p>
<p>无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量，一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况会不同。</p>
<p>由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存，过度使用闭包可能会导致内存占用过多。</p>
<p>闭包只能取得包含函数中任何变量的最后一个值。闭包保存的是整个变量对象，而不是某个特殊的变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的结果是都返回10，因为每个函数的作用域链中都保存着<code>createFunctions()</code>函数的活动对象，所以它们引用的都是同一个变量i。当<code>createFunctions()</code>函数返回后，变量i的值是10，此时每个函数都引用着保存变量i的同一个变量对象，所以在每个函数内部i的值都是10.可以通过创建另一个匿名函数强制让闭包的行为符合预期：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> num;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上每个函数会按照预期返回不同的索引值。定义了一个匿名函数，并将立即执行该匿名函数的结果赋给数组。这里的匿名函数有一个参数<code>num</code>，也就是最终的函数要返回的值。在调用这个匿名函数时，传入了变量<code>i</code>。由于函数参数是按值传递的，所以就会将变量<code>i</code>的当前值复制给参数<code>num</code>。而在这个匿名函数的内部，又创建并返回了一个访问<code>num</code>的闭包。这样一来，<code>result</code>数组中每个函数都有自己<code>num</code>变量的一个副本，因此可以返回各自不同的数值了。</p>
<p>在闭包中使用<code>this</code>对象可能会导致问题。每个函数在被调用的时候都自动取得两个特殊变量：<code>this</code>和<code>arguments</code>。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。不过把外部作用域中的<code>this</code>对象保存在一个闭包能够访问到的变量中，就可以让闭包访问该对象了。</p>
<p>如果闭包作用域链中保存着一个HTML元素，那么意味着该元素将无法被销毁。需要手动设置为<code>null</code>。</p>
<p>JavaScript没有块级作用域的概念，在块语句中定义的变量，实际上是在包含函数中而非语句中创建的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">		alert(i);</span><br><span class="line">	&#125;</span><br><span class="line">	alert(i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> i; <span class="comment">/* 重新声明函数 */</span></span><br><span class="line">alert(i); <span class="comment">/* count */</span></span><br></pre></td></tr></table></figure>
<p>JavaScript不会提示是否多次声明了同一个变量，遇到这种情况，会忽略第二次声明。（如果初始化了就不一样了）<br>匿名函数可以用来模仿块级作用域，也叫私有作用域，语法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">/* 这里是块级作用域 */</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>特权方法：有权访问私有变量和私有函数的公有方法。两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 特权方法 */</span></span><br><span class="line">	<span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		privateVatiable++;</span><br><span class="line">		<span class="keyword">return</span> privateFunction();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能够在构造函数中定义特权方法，是因为特权方法作为闭包邮券访问在构造函数中定义的所有变量和函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">		name = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Sam"</span>);</span><br><span class="line">alert(person.getName); <span class="comment">/* Sam */</span></span><br><span class="line">person.setName(<span class="string">"Amy"</span>);</span><br><span class="line">alert(person.getName); <span class="comment">/* Amy */</span></span><br></pre></td></tr></table></figure>
<p>通过私有作用域中定义私有变量或函数，同样可以创建特权方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">provateFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	MyObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 公有/特权方法 */</span></span><br><span class="line">	MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		privateVariable++;</span><br><span class="line">		<span class="keyword">return</span> privateFunction();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>以上方法创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其公有方法。公有方法是在原型上定义的，这一点体现了典型的原型模式。需要注意的是，这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，在声明MyObject的时候也没有使用var关键字。初始化未经声明的变量总是会创建一个全局变量，因此MyObject成了一个全局变量，能够在私有作用域之外被访问到。但是，在严格模式下，给未经声明的变量赋值会导致错误。</p>
<p>这个模式与在构造函数总定义特权方法的主要区别在于，私有变量和函数时由实例共享的。由于特权方法是在原型上定义的，因此所有的实例都适用同一个函数，而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。</p>
<p>模块模式：为单例创建私有变量和特权方法。</p>
<p>JavaScript是以对象字面量的方式创建单例对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = &#123;</span><br><span class="line">	name : value,</span><br><span class="line">	method : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">/* 方法代码 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>模块模式通过为单例添加私有变量和特权方法使其得到增强：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 特权/公有方法和属性 */</span></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		publicProperty : <span class="literal">true</span>,</span><br><span class="line">		publicMethod : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			privateVariable++;</span><br><span class="line">			<span class="keyword">return</span> privateFunction();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>这个模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，首先定义了私有变量和函数。然后，将一个对象字面量作为函数的值返回。返回对象字面量中只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时有需要维护其私有变量时非常有用。以这种模式创建的单例都是Object的实例。</p>
<p>对于单例必须是谋政类型的实例，同时还必须添加某些属性和方法的情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> privatevariable = <span class="number">10</span>;</span><br><span class="line">	funtion privateFunction()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();</span><br><span class="line">	</span><br><span class="line">	object.publicProperty = <span class="literal">true</span>;</span><br><span class="line">	object.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		privateVaritable++;</span><br><span class="line">		<span class="keyword">return</span> privateFunction();</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<hr>
<p>以上，JavaScript的面向对象以及函数，涉及到一些原理。坦白说理解的很模糊，因此下一步会再查阅一些相关的资料，并结合实际应用理解一下。</p>
<hr>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

