<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Echo Meng">
  <!-- Open Graph Data -->
  <meta property="og:title" content="《设计模式：可复用面向对象软件的基础》"/>
  <meta property="og:description" content="Can&#39;t help but code." />
  <meta property="og:site_name" content="Echo Meng&#39;s Blog"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://www.echomeng.cn"/>
  
    <link rel="alternate" href="/atom.xml" title="Echo Meng&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>Echo Meng's Blog</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">《设计模式：可复用面向对象软件的基础》</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/EchoMeng/">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:mengxiangxxa@163.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Echo Meng</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-11-26</span>
            <span class="time">09:25:14</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/技术/">技术</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/设计模式/">#设计模式</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
            
              <div id="toc" class="toc-article">
                <strong class="toc-title">文章目录</strong>
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#设计模式的描述"><span class="toc-text">设计模式的描述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#设计模式"><span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建型模式"><span class="toc-text">创建型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#abstract-factory-抽象工厂"><span class="toc-text">abstract factory 抽象工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#builder-生成器"><span class="toc-text">builder 生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#factory-mothod-工厂方法"><span class="toc-text">factory mothod 工厂方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prototype-原型"><span class="toc-text">prototype 原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#singleton-单例"><span class="toc-text">singleton 单例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构型模式"><span class="toc-text">结构型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#adapter-适配器"><span class="toc-text">adapter 适配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bridge-桥接"><span class="toc-text">bridge 桥接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#composite-组合"><span class="toc-text">composite 组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dectorator-装饰"><span class="toc-text">dectorator 装饰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#facade-外观"><span class="toc-text">facade 外观</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flyweight-享元"><span class="toc-text">flyweight 享元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy-代理"><span class="toc-text">proxy 代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#行为模式"><span class="toc-text">行为模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#chain-of-responsibility-职责链"><span class="toc-text">chain of responsibility 职责链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#command-命令"><span class="toc-text">command 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interpreter-解释器"><span class="toc-text">interpreter 解释器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iterator-迭代器"><span class="toc-text">iterator 迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mediator-中介器"><span class="toc-text">mediator 中介器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memento-备忘录"><span class="toc-text">memento 备忘录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#observer-观察者"><span class="toc-text">observer 观察者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#state-状态"><span class="toc-text">state 状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strategy-策略"><span class="toc-text">strategy 策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#template-method-模版方法"><span class="toc-text">template method 模版方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#visitor-访问者"><span class="toc-text">visitor 访问者</span></a></li></ol></li></ol></li></ol>
              </div>
              
          <p>吐血…终于码完了大论文，学习一下设计模式，尝试搞明白怎样才能做到“面向对象”</p>
<a id="more"></a>
<h1 id="设计模式的描述"><a href="#设计模式的描述" class="headerlink" title="设计模式的描述"></a>设计模式的描述</h1><p>按照目的准则将设计模式分为创建型、结构型、行为型。创建型模式与对象的创建有关，结构型模式处理类或者对象的组合，行为型模式对类或者对象怎样交互和怎样分配指责进行描述。</p>
<p>面向对象设计最困难的部分是将系统分解成对象集合，因为要考虑的因素很多：封装、粒度、依赖关系、灵活性、性能、演化、复用等等，它们都影响着系统的分解，并且这些因素通常还是相互冲突的。</p>
<p>发送给对象的请求和它的相应操作在运行时刻的连接称为动态绑定。动态绑定允许在运行时刻批次替换有相同接口的对象，这种可替换性称为多态。多态简化了客户的定义，使得对象间彼此独立，并可以在运行时刻动态改变它们的相互关系。</p>
<p>抽象类：抽象类的主要目的是为它的子类定义公共接口。一个抽象类能把它的部分或者全部操作的实现延迟到子类中，因此，一个抽象类不能被实例化。在抽象类中定义却没有实现的操作被称为抽象操作。</p>
<p>混入类：混入类是给其他类提供可选择的接口或者功能的类。它与抽象类一样不能实例化。混入类要求多继承。</p>
<p>面向对象系统中功能复用的两种最常用技术是类继承和对象组合。类继承这种通过生成子类的复用通常被称为白箱复用，在继承方式中，父类的内部细节对子类可见；对象组合是通过组装或者组合对象来获得，对象组合要求被组合的对象具有良好定义的接口，这种复用风格被称为黑箱复用，因为对象的内部细节是不可见的。</p>
<p>类继承是在编译时刻静态定义的，并且可以直接使用，因为程序设计语言直接支持类继承。但是因为类继承在编译时刻就已经定义好了，所以无法在运行时刻改变从父类继承的实现。而且，父类通常至少定义了部分子类的具体表示，因为继承对子类揭示了父类的实现细节，破坏了封装性。子类中的实现和父类有紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。这种依赖关系限制了灵活性并最终限制了复用性。</p>
<p>对象组合是通过获得对其他对象的引用而在运行时刻动态定义的。组合要求对象遵守彼此的接口约定，进而要求更仔细的定义接口，而这些接口并不妨碍将一个对象和其他对象一起使用。因为对象只能通过接口访问，所以我们并不破坏封装性，只要类型一致，运行时刻还可以用一个对象来替代另一个对象，更进一步，因为对象的实现是基于接口写的，所以实现上存在较少的依赖关系。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="abstract-factory-抽象工厂"><a href="#abstract-factory-抽象工厂" class="headerlink" title="abstract factory 抽象工厂"></a>abstract factory 抽象工厂</h3><p>提供一个创建一些列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<p>在面向对象的概念中，所有的对象都是通过类描绘的，但是并不是所有的类都是用来描绘对象的。如果一个类中没有包含足够的信息来描绘一个对象，这样的类就是抽象类。抽象类出了不能实例化对象之外，类的其他功能仍然存在，成员变量、成员方法以及构造方法的访问方式和普通类一致。</p>
<p>AbstractFactory方法的特点：</p>
<ol>
<li>它分离了具体的类。抽象类封装了对象的创建过程，能够将类和对象之间分离，客户可以通过抽象类提供的抽象接口操纵实例。</li>
<li>它使实例易于修改。一个具体的工厂类在一个应用中只出现一次，也就是在它初始化的时候，可以通过修改这个抽象类来实现对继承于这个抽象类的所有实例的修改。</li>
<li>它有利于实例的一致性。设计成一个系列，保证这个系列的实例的一致。</li>
<li>难以支持新种类的产品。难以扩展抽象工厂以生产新种类的产品。如果扩展抽象接口，将会涉及到所有的实例的改变。</li>
</ol>
<p>研究了一下发现：在iOS中的“类簇”其实就是抽象工厂。例如<code>NSNumber</code>调用初始化方法后返回的对象是<code>NSCFNumber</code>和<code>NSCFBoolean</code>工厂，这两个工厂继承自<code>NSNumber</code>，拥有同样的一些方法，例如<code>intValue</code>和<code>boolValue</code>，在<code>NSNumber</code>角度来看，这就是抽象工厂。</p>
<p>参考：<a href="https://juejin.im/entry/5923ca53570c350069c8a4b7" target="_blank" rel="noopener">设计模式与iOS</a></p>
<h3 id="builder-生成器"><a href="#builder-生成器" class="headerlink" title="builder 生成器"></a>builder 生成器</h3><p>生成器模式是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>以下情况使用builder模式：</p>
<ol>
<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时；</li>
<li>当构造过程必须允许被构造的对象有不同的表示时。</li>
</ol>
<p>生成器模式和抽象工厂有什么区别？</p>
<style>
table {
    margin: auto;
}
table, th, td{
    border: 1px solid #DCDCDC;
}
table th {
    width: 250px;
}
</style>

<table>
<thead>
<tr>
<th style="text-align:center">生成器</th>
<th style="text-align:center">抽象工厂</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">构建复杂对象</td>
<td style="text-align:center">构建简单或者复杂对象</td>
</tr>
<tr>
<td style="text-align:center">以多个步骤构建对象</td>
<td style="text-align:center">以单一步骤构建对象</td>
</tr>
<tr>
<td style="text-align:center">以多种方式构建对象</td>
<td style="text-align:center">以单一方式构建对象</td>
</tr>
<tr>
<td style="text-align:center">在构建过程的最后一步返回产品</td>
<td style="text-align:center">立刻返回产品</td>
</tr>
<tr>
<td style="text-align:center">专注一个特定产品</td>
<td style="text-align:center">强调一套产品</td>
</tr>
</tbody>
</table>
<p>builder模式的效果：</p>
<ol>
<li>可以改变一个产品的内部表示。builder对象提供给导向器一个构造产品的抽象接口，该接口使得生成器可以隐藏这个产品的表示和内部结构，同时也隐藏了该产品是如何装配的。因为产品是通过抽象接口构造的，在改变产品的内部表示时所要做的只是定义一个新的生成器。</li>
<li>将构造代码和表示代码分开。builder模式通过封装一个复杂对象的创建和表示方式提高了对象的模块性，客户不需要知道定义产品内部结构的类的所有信息，这些类是不出现在builder接口中的。每个concreteBuilder包含了创建和装配一个特定产品的所有代码。这些代码只需要写一次，然后不同的director可以复用它以在相同部件集合的基础上构建不同的product。</li>
<li>可以实现对构造过程的更精细的控制。builder模式与一下子就生成产品的创建型模式不同，他是在导向者的控制下一步一步构造产品。仅当该产品完成时导向者才从生产器中取回它，因此builder接口相比其他创建型模式能够更好的反映产品的构造过程，实现更精细的构建过程，更精细的控制产品的内部结构。</li>
</ol>
<h3 id="factory-mothod-工厂方法"><a href="#factory-mothod-工厂方法" class="headerlink" title="factory mothod 工厂方法"></a>factory mothod 工厂方法</h3><h3 id="prototype-原型"><a href="#prototype-原型" class="headerlink" title="prototype 原型"></a>prototype 原型</h3><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<p>当一个系统应该独立于它的产品创建、构成和表示时，需要使用Prototype模式，以及当要实例化的类是在运行时刻指定时，或者为了避免创建一个与产品类层次平行的工厂类层次时，或者当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次使用合适的状态手工实例化该类要方便一些。达到的效果是对客户隐藏了具体的产品类，因此减少了客户知道的名字的数目，此外，还可以使客户无需改变即可使用与特定应用相关的类，与抽象工厂模式和生成器模式达到的效果相同。</p>
<p>JavaScript中使用原型模式，在iOS开发中好像没见到相关的应用，但是copy操作和原型模式的克隆方法可以做一个分辨。</p>
<p>原型模式的另外一些优点：</p>
<ol>
<li>运行时刻增加或者删除产品。原型允许只通过客户注册原型实例就将一个新的具体的产品类并入系统。它比其他的创建型模式更为灵活，因为客户可以在运行时刻建立和删除原型。</li>
<li>改变值以指定新的对象。高度动态的系统允许通过对象符合定义新的行为，例如通过为一个对象变量指定值，而且并不定义新的类。通过实例化已有类并且将这些实例注册为客户对象的原型，就可以有效定义新类别的对象。客户可以将职责代理给原型，从而表现出新行为。这种设计使得用户无需编程即可定义新的类，实际上克隆一个原型类似于实例化一个类。原型模式可以极大的减少系统所需要的类的数目。</li>
<li>改变结构以指定新对象。许多应用由部件和子部件来创建对象，为了方便起见，这样的应用通常允许实例化复杂的、用户定义的结构。原型模式也支持这一点，只要将对象clone实现为深拷贝即可。</li>
<li>减少子类的构造。工厂方法通常会产生一个与产品类层次平行的creator类层次。原型模式使得你克隆一个原型而不是请求一个工厂方法去产生一个新的对象，因此根本不需要creator类层次。这一优点主要适用于像C++这样的不将类作为一级类对象的语言。但是像oc，smalltalk这样的语言，总是可以用一个类对象作为生成者，类对象已经起到了原型一样的作用。</li>
<li>用类动态配置应用。一些运行时刻环境允许动态的将类装载在应用中。在像C++这样的语言中，原型模式是利用这种功能的关键。一个希望创建动态载入类的实例的应用不能静态引用类的构造器，而应该由运行环境在载入时自动创建每个类的实例，并用原型管理器来注册这个实例，这样应用就可以想原型管理器请求新装载的类的实例，这些类原本并没有和程序相连接。</li>
<li>原型模式的主要缺陷是每一个原型的子类都必须实现clone操作，这样可能很困难。例如当所考虑的类已经存在时就难以新增clone操作。当内部包括一些不支持拷贝或者有循环引用的对象时，实现克隆可能变得困难。</li>
</ol>
<p>这里我的上一篇关于JavaScript中的原型的文章可以作为一个例子帮助理解。<a href="https://www.echomeng.cn/2018/11/04/JavaScript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/">JavaScript中的继承和原型链</a></p>
<h3 id="singleton-单例"><a href="#singleton-单例" class="headerlink" title="singleton 单例"></a>singleton 单例</h3><p>单例模式可以保证一个类只有一个实例，并提供一个访问它的全局访问点。</p>
<p>想要达到这一目的，一个办法是让类自身负责保存它的唯一实例，这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求），并且可以提供一个访问该实例的方法。</p>
<p>在iOS中单例使用很多，例如<code>UIApplication</code>以及<code>NSFileManager</code>等</p>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="adapter-适配器"><a href="#adapter-适配器" class="headerlink" title="adapter 适配器"></a>adapter 适配器</h3><p>将一个类的接口转换成客户希望的另一个接口，adapter模式使得原本由于接口不兼容而不能一起工作的类可以一起工作。</p>
<p>在iOS开发中也有用到适配器模式，当引入某个SDK中一些方法和app不兼容时，利用协议为适配器类约定方法，将SDK中方法封装到协议方法里，并添加上自己app需要进行的处理。</p>
<p>以下情况使用adapter模式：</p>
<ol>
<li>想使用一个已经存在的类，而它的接口不符合需求</li>
<li>想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作</li>
<li>仅适用于对象adapter：想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口，对象适配器可以适配它的父类接口。</li>
</ol>
<p>类适配器和对象适配器有不同的权衡。</p>
<style>
img {
    margin:0 auto;
    display: block;
}
</style>

<p>类适配器：<br><img src="/images/设计模式/类适配器.png" alt="类适配器"><br>对象适配器：<br><img src="/images/设计模式/对象适配器.png" alt="对象适配器"></p>
<ul>
<li><b>类适配器</b>使用多重继承对一个接口与另一个接口进行匹配<ul>
<li>用一个具体的adapter类对adaptee和target进行匹配。结果是当我们想要匹配一个类以及所有的子类时，类adapter将不能胜任工作。</li>
<li>使用adapter可以重定义adaptee的部分行为，因为adapter是adaptee的一个子类。</li>
<li>仅仅引入了一个对象，并不需要额外的指针以间接得到adaptee。</li>
</ul>
</li>
<li><b>对象适配器</b>依赖于对象组合<ul>
<li>允许一个adapter与多个adaptee，即adaptee本身以及它的所有子类同时工作。adapter也可以一次给所有的adaptee添加功能。</li>
<li>使得重定义adaptee的行为比较困难，这就需要生成adaptee的子类并且使得adapter引用这个子类而不是引用adaptee本身。</li>
</ul>
</li>
</ul>
<h3 id="bridge-桥接"><a href="#bridge-桥接" class="headerlink" title="bridge 桥接"></a>bridge 桥接</h3><h3 id="composite-组合"><a href="#composite-组合" class="headerlink" title="composite 组合"></a>composite 组合</h3><p>将对象组合成树形结构以表示“整体-部分”的层次结构，使用户对单个对象和组合对象的使用具有一致性。</p>
<p>iOS中的UIKit框架中UIView的设计能够体现组合设计模式。UIView是可以添加UIView类和其子类对象的，对象的渲染以及其他操作会遍历到子类中依次进行。</p>
<p>在实现组合模式的时候需要考虑的几个问题：</p>
<ol>
<li>显式的父部件引用。保持从子部件到父部件的引用能简化组合结构的遍历和管理。父部件的引用可以简化结构的上移和组件的删除，同时父部件引用也支持<code>Chain of Responsibility</code>。通常在组合类中定义父部件引用，<code>Leaf</code>和<code>Composite</code>类可以继承这个引用以及管理这个引用的那些操作。对于父部件的引用，必须维护一个不变式，即一个组合的所有子节点以这个组合为父节点，而反之该组合以这些节点为子节点。保证这一点最容易的方法是，仅当在一个组合中增加或者删除一个组件时，才改变这个组件的父部件。如果能在组合类的增加和删除操作中实现这种方法，那么所有的子类都可以继承这一方法，并且将自动维护这一不变式。</li>
<li>共享组件。</li>
<li>最大化组合接口。组合模式的目的之一是使得用户不知道他们正在使用的具体的<code>Leaf</code>和<code>Composite</code>类，为了达到这一目的，组合类应该为<code>Leaf</code>和<code>Composite</code>类尽可能多定义一些公共接口。</li>
<li>声明管理子部件的操作。需要在安全性和透明性之间作出权衡选择：<ul>
<li>在类层次结构的根部定义子节点管理接口的方法具有良好的透明性，因为可以一致的使用所有的组件，但是这一方法是以安全性为代价的，因为客户有可能会做一些无意义的事情，例如在<code>Leaf</code>中增加和删除对象等。</li>
<li>在<code>Composite</code>类中定义管理子部件的方法具有良好的安全性，因为在C++这样的静态类型语言中，在编译时任何从<code>Leaf</code>中增加或者删除对象的尝试都将被发现，但是这又损失了透明性，因为这样<code>Leaf</code>和<code>Composite</code>具有不同的接口。</li>
</ul>
</li>
<li>子部件排序。</li>
<li>使用高速缓冲存储改善性能。</li>
<li>垃圾回收机制。</li>
<li>储存的数据结构。可以用到的包括列表、树、数组、hash表。</li>
</ol>
<h3 id="dectorator-装饰"><a href="#dectorator-装饰" class="headerlink" title="dectorator 装饰"></a>dectorator 装饰</h3><p>将组件嵌入另一个对象中，这个嵌入的对象称为装饰。这个装饰和它所装饰的组件接口一致，因此它对使用该组件的客户透明。它将客户请求转发给该组件，并且可能在转发前后执行一些额外的动作。透明性使得你可以递归的嵌套多个装饰，从而可以添加任意多的功能。</p>
<p>以下情况使用装饰模式：</p>
<ol>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；</li>
<li>处理可以撤销的职责；</li>
<li>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种可能的情况是因为类定义被隐藏，或者类定义不能用于生成子类。</li>
</ol>
<p>优点和缺点：</p>
<ol>
<li>比静态继承更灵活。和对象的静态继承相比，装饰者模式提供了更加灵活的向对象添加职责的方式，可以用添加和分离的方法，用装饰在运行时刻增加和删除职责。相比之下，继承机制要求为每个添加的职责创建一个新的子类，这会产生很多新的类，并且会增加系统的复杂度。此外，为一个特定的组件类提供多个不同的装饰者类，使得你可以对一些职责进行混合和匹配。</li>
<li>避免在层次结构高层的类有太多的特征。</li>
<li>decorator是一个透明的包装，如果从对象标示的角度出发，一个被装饰了的组件和这个组件是有差别的，因此，使用装饰时不应该依赖对象标示。</li>
<li>有许多小对象。很容易进行定制，但是很难学习这些系统，debug困难。</li>
</ol>
<p>iOS中的分类（Category）是一种变相装饰者模式，他的原理是在编译的时候动态的为原来的类添加方法，而不是拥有一个原始类的实例，严格意义上不是装饰者，但是和装饰者思想很像。</p>
<h3 id="facade-外观"><a href="#facade-外观" class="headerlink" title="facade 外观"></a>facade 外观</h3><h3 id="flyweight-享元"><a href="#flyweight-享元" class="headerlink" title="flyweight 享元"></a>flyweight 享元</h3><h3 id="proxy-代理"><a href="#proxy-代理" class="headerlink" title="proxy 代理"></a>proxy 代理</h3><p>为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>代理模式在iOS中应用十分常见，协议、代理、委托对象共同构成了代理模式：</p>
<ul>
<li>协议：约束代理对象需要进行的操作</li>
<li>代理：执行被指派的操作</li>
<li>委托：指派任务的角色</li>
</ul>
<p>在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用proxy模式，一些常见的使用这种代理模式的场景：</p>
<ol>
<li>远程代理：为一个对象在不同的地址空间提供局部代理。</li>
<li>虚代理：根据需要创建开销很大的对象。</li>
<li>保护代理：控制对原始对象的访问，用于对象应该有不同的访问权限的时候。</li>
<li>智能指引：取代了简单的指针，在访问对象时执行一些附加操作，它的典型用途包括：<ul>
<li>对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它；</li>
<li>当第一次引用一个持久对象时，将它装入内存；</li>
<li>在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。</li>
</ul>
</li>
</ol>
<p>代理模式在访问对象时引入了一定程度的间接性，远程代理可以隐藏一个对象存在于不同地址空间的事实；虚代理剋呀进行最优化，例如可以更具要求创建对象；保护代理和职能指引都允许在访问一个对象时有一些附加的内务处理。</p>
<p>代理模式还可以对用户隐藏写时复制（copy-on-write）的优化方式，该油画与根据需要创建对象有关。拷贝一个庞大而复杂的对象开销很大，对于没有修改的拷贝，开销没有必要，用代理延迟这一拷贝过程，保证只有当这个对象被修改的时候才能进行拷贝。</p>
<h2 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h2><h3 id="chain-of-responsibility-职责链"><a href="#chain-of-responsibility-职责链" class="headerlink" title="chain of responsibility 职责链"></a>chain of responsibility 职责链</h3><p>使多个对象都有机会处理请求，从而避请求的发送者和接受者之间的耦合关系。将这些对象连城一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。</p>
<p>在以下情况下使用职责链：</p>
<ol>
<li>有多个对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。</li>
<li>想在不明确指定接受者的情况下，想多个对象中的一个提交一个请求。</li>
<li>可处理一个请求的对象集合应被动态指定。</li>
</ol>
<p>职责链的优缺点：</p>
<ol>
<li>降低耦合度。该模式使得一个对象无需知道是其他哪一个对象处理其请求，对象仅需知道该请求会被正确的处理，接受者和发送者都没有对方的明确信息，并且链中对象不需要知道链的结构。结果是，职责链可以简化对象的相互连接，仅需保持一个指向其后继者的引用，而不需要保持它所有的候选者的引用。</li>
<li>增强了给对象指派职责的灵活性。挡在对象中分派职责时，职责链有更多的灵活性，可以通过在运行时刻对该链进行动态的增加或者修改来增加或者改变处理一个请求的职责，可以将这种机制与静态的特例化处理对象的继承机制结合起来使用。</li>
<li>不保证被接受。既然一个请求没有明确的接受者，那么就不能保证它一定会被处理，一个情切也可能因为该链没有正确配置而没有被处理。</li>
</ol>
<h3 id="command-命令"><a href="#command-命令" class="headerlink" title="command 命令"></a>command 命令</h3><p>将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。</p>
<p>iOS中的<code>NSInvocation</code>以及<code>NSUndoManager</code>借助了这种设计模式。前者是一种消息调用方法，后者可以提供撤销机制。</p>
<p>以下情况可使用命令模式：</p>
<ol>
<li>抽象出等待执行的动作以参数化某对象。可以使用过程语言中的回调函数表达这种参数化的机制。命令模式是回调机制的一个面向对象的替代品。</li>
<li>在不同的时刻指定、排列或者执行请求。一个命令对象可以有一个与初始请求无关的生存期，如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可以将负责该请求的命令对象传送给另一个不同的进程并在那里实现这个请求。</li>
<li>支持取消操作。</li>
<li>支持修改日志。</li>
<li>用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务的信息系统中很常见。一个事务封装了对数据的一组变动。命令模式提供了对事务进行建模的方法。命令有一个公共的接口，使你可以使用同一种方式调用所有的事物，同时使用该模式也易于添加新事务以扩展系统。</li>
</ol>
<h3 id="interpreter-解释器"><a href="#interpreter-解释器" class="headerlink" title="interpreter 解释器"></a>interpreter 解释器</h3><h3 id="iterator-迭代器"><a href="#iterator-迭代器" class="headerlink" title="iterator 迭代器"></a>iterator 迭代器</h3><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p>
<h3 id="mediator-中介器"><a href="#mediator-中介器" class="headerlink" title="mediator 中介器"></a>mediator 中介器</h3><h3 id="memento-备忘录"><a href="#memento-备忘录" class="headerlink" title="memento 备忘录"></a>memento 备忘录</h3><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>
<p>别名：Token</p>
<p>一个备忘录是一个对象，它储存另一个对象在某个瞬间的内部状态，而后者称为备忘录的原发器。当需要设置原发器的检查点时，取消操作机制会向原发器请求一个备忘录。原发器用描述当前状态的信息初始化该备忘录。只有原发器可以向备忘录中存取信息，备忘录对其他的对象“不可见”。</p>
<p>以下情况使用备忘录模式：</p>
<ol>
<li>必须保存一个对象在某个时刻的（部分）状态，这样以后需要时餐能恢复到先前的状态。</li>
<li>如果一个用接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。</li>
</ol>
<p>在iOS中使用备忘录模式的地方：</p>
<ul>
<li>归档<ul>
<li>备忘录对象即为归档对象</li>
<li>被归档的对象为操作对象（原发器）</li>
<li>文件系统则为备忘录管理者</li>
</ul>
</li>
<li>属性列表序列化</li>
</ul>
<p>再如游戏进度的存储和读取。</p>
<h3 id="observer-观察者"><a href="#observer-观察者" class="headerlink" title="observer 观察者"></a>observer 观察者</h3><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p>将一个系统分割成一系列相互协作的类有一个常见的副作用：需要维护相关对象间的一致性。我们不希望为了维持一执行而使各类紧密耦合，因为这样降低了它们的可重用性。</p>
<p>以下适用于观察者模式：</p>
<ol>
<li>当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这二者封装在独立的对象中以使他们可以各自独立的改变和复用。</li>
<li>当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。</li>
<li>当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，不希望这些对象时紧密耦合的。</li>
</ol>
<p>观察者模式的一些优缺点：</p>
<ol>
<li>目标和观察者之间的抽象耦合。一个目标所知道的仅仅是它由一系列的观察者，每个都符合抽象的观察者累的简单接口，目标不知道任何一个观察者属于哪一个具体的类，这样目标和观察者之间的耦合是抽象的和最小的。因为目标和观察者不是紧密耦合的，它们可以属于一个系统中的不同抽象层次，一个处于较低层次的目标对象可与一个处于较高层次的观察者通信并通知他，这样就保持了系统层次的完整。如果目标和观察者混在一起，那么得到的对象要么横贯两个层次（违反了层次性），要么必须放在这两层的某一层中（这样可能会损害抽象层次）。</li>
<li>支持广播通信。不像通常的请求，目标发送的通知不需要指定他的接受者。通知被自动广播给所有已向该目标对象登记的有关对象。目标对象并不关心到底有多少对象对自己感兴趣，它唯一的责任就是通知他的观察者，这给了在任何时刻增加或者删除观察者的自由，处理或者是忽略一个通知取决于观察者。</li>
<li>意外的更新。因为一个观察者并不知道其他的观察者的存在，它可能会改变目标的最终代价一无所知。在目标上一个看似无害的操作可能会引起一系列对观察者以及依赖于这些观察者的那些对象的更新。此外，如果依赖准则的定义或者维护不当，常常会引起错误的更新，这些错误常常难以捕捉。</li>
</ol>
<p>在iOS中有两种观察者模式的实现：</p>
<ol>
<li>通知机制</li>
<li>KVO</li>
</ol>
<h3 id="state-状态"><a href="#state-状态" class="headerlink" title="state 状态"></a>state 状态</h3><h3 id="strategy-策略"><a href="#strategy-策略" class="headerlink" title="strategy 策略"></a>strategy 策略</h3><p>定义一系列的算法，把它们一个个封装起来，并且使它们<br>可以相互替换，使得算法可以独立于使用它的客户而变化，避免将算法的具体细节暴露给外部。</p>
<p>在以下情况使用策略模式：</p>
<ol>
<li>许多相关的类仅仅是行为有区别。策略提供了一种用多个行为中的一个行为来配置一个类的方法。</li>
<li>需要使用一个算法的不同变体。</li>
<li>短发使用用户不应该知道的数据。</li>
<li>一个类定义个了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入个字的策略类中来代替这些语句。</li>
</ol>
<p>在iOS开发中，MVC模式中涵盖了策略模式，体现为：控制器作为试图的策略类，视图在没有控制器的情况下，显示应该是一样的，但是不同的控制器将会给视图赋予不同的数据以及输出模式。</p>
<h3 id="template-method-模版方法"><a href="#template-method-模版方法" class="headerlink" title="template method 模版方法"></a>template method 模版方法</h3><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod使得子类可以不改变一个算法的结构及可以重新定义该算法的某些特定步骤。</p>
<p>在iOS中最典型的例子是<code>UIView</code>中的<code>drawRect</code>方法，该方法是用于描述<code>UIView</code>长什么样子，这个方法留给子类去子类去实现，从而实现不同绘制。</p>
<p>适用性：</p>
<ol>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类实现；</li>
<li>各子类中公共的行为应该被提取出来并集中到一个公共的父类中，以避免代码重复。首先识别代码中的不同之处，并且将不同之处分离为不同的操作，最后用一个调用这些新的操作的方法来替换这些不同的代码。</li>
<li>控制子类的扩展。模版方法只在特点电调用“hook”操作，这样就只允许在这些点进行扩展。</li>
</ol>
<p>模版方法调用下列类型的操作：</p>
<ul>
<li>具体的操作</li>
<li>具体的AbstractClass的操作</li>
<li>原语操作，即抽象操作</li>
<li>Factory Method</li>
<li>hook operation。它提供了缺省的行为，子类可以在必要时进行扩展，一个钩子操作在缺省操作中通常是一个空操作。</li>
</ul>
<p>很重要的一点是模版方法应该指明哪些操作是钩子操作，可以被重定义，以及哪些是抽象操作，必须被重定义。要有效的重用一个抽象类，子类编写者必须明确连接哪些操作是设计为有待重定义的。在父类的模版中调用钩子操作。子类可以重定义这个钩子操作。</p>
<h3 id="visitor-访问者"><a href="#visitor-访问者" class="headerlink" title="visitor 访问者"></a>visitor 访问者</h3>
        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

